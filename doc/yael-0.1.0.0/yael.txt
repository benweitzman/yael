-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/benweitzman/yael#readme</a>
@package yael
@version 0.1.0.0


-- | Yael is an effect system that models effects as records. This module
--   contains the core functionality needed to define and use effects.
--   
--   In Yael, each effect is a record, paremeterized by a <a>Monad</a>,
--   <tt>m</tt>. For example
--   
--   <pre>
--   data MyEffect m = MyEffect
--     { _myMethod1 :: String -&gt; m Bool
--     , _myMethod2 :: m Int -&gt; m [Int]
--     }
--   </pre>
--   
--   Each field in an effect record is a "method" of that effect. Methods
--   after often functions, but they don't have to be. They can be of the
--   form `m a` for some <tt>a</tt>, or they can simply not refer to
--   <tt>m</tt> at all. As seen in <tt>MyEffect</tt>, methods can be
--   first-order, meaning that <tt>m</tt> only appears in the result of a
--   functional method, or they can be higher order, meaning that
--   <tt>m</tt> appears in the arguments of a functional method. Most
--   methods are first-order, but higher-order methods are useful to
--   represent effects that can wrap other effectful code, for example when
--   working with transactional data
module Yael.Eff

-- | <a>EffT</a> is a monad transformer which adds an effect (or collection
--   of effects) <tt>f</tt> to an underlying <a>Monad</a> <tt>m</tt>.
data EffT (f :: (* -> *) -> *) (m :: * -> *) (a :: *)
pattern EffT :: (f m -> m a) -> EffT f m a

-- | Run an effectful computation of <tt>f</tt> in <tt>m</tt> by providing
--   a particular instantiation of that effect.
runEffT :: forall f m a. EffT f m a -> f m -> m a

-- | Synonym for the <a>EffT</a> constructor. Lift a computation in
--   <tt>m</tt> with access to the effect <tt>f</tt> into <tt>EffT f m</tt>
liftEffT :: (f m -> m a) -> EffT f m a
shareEffT :: f m -> (Lower f m m -> EffT f m a) -> m a

-- | Lift a first-order computation that is expressible wholly through
--   <tt>g</tt> into <a>EffT</a>. This is most commonly used to define
--   convient method accessors generically in <a>EffT</a>.
--   
--   Returning to the <tt>MyEffect</tt> example above, we'll see that
--   <tt>_myMethod1</tt> has type <tt>MyEffect m -&gt; String -&gt; m
--   Bool</tt>. The <tt>MyEffect m</tt> paremeter is cumbersome to work
--   with, so we can use <a>withEffT</a>:
--   
--   <pre>
--   myMethod1 :: (HasEff MyEffect f m) =&gt; String -&gt; EffT f m Bool
--   myMethod1 s = withEffT $ myEffect -&gt; _myMethod1 myEffect s
--   </pre>
withEffT :: HasEff g f m => (forall n. Monad n => g n -> n a) -> EffT f m a

-- | Lift a higher-order computation in <tt>g</tt> into <a>EffT</a>.
--   
--   <a>withEffT'</a> is similar to <a>withEffT</a>, but it provides an
--   additional "lowering" function that is useful for working with higher
--   order computations. For example
--   
--   <pre>
--   myMethod2 :: (HasEff MyEffect f m) =&gt; EffT f m Int -&gt; EffT f m [Int]
--   myMethod2 m = withEffT' $ lower myEffect -&gt; _myMethod2 myEffect (lower m)
--   </pre>
withEffT' :: HasEff g f m => (forall n. Monad n => Lower f m n -> g n -> n a) -> EffT f m a
withEffT'' :: HasEff g f m => (forall n. Monad n => Lower f m n -> Raise f m n -> g n -> n a) -> EffT f m a
type Lower f m n = EffT f m ~> n
type Raise f m n = n ~> EffT f m
type f ~> g = forall x. f x -> g x

-- | Modify a computational context. Useful for attaching behavior to a
--   specific scope. Compare to <a>local</a> in <a>Control.Monad.Reader</a>
localEffT :: Project f g => (g m -> g m) -> EffT f m a -> EffT f m a

-- | Transform an entire effect context into a new context. Useful for
--   resolving one effect in a context without resolving every effect.
mapEffT :: Monad m => (f m -> g m) -> EffT g m a -> EffT f m a

-- | Type synonym expressing that an <tt>g</tt> is available for use within
--   the wider context <tt>f</tt>
type HasEff g f m = (Project f g, Monad m)

-- | Type synonym expressing that a set of effects <tt>xs</tt> are all
--   available within the wider context f. <tt>xs</tt> is expressed as a
--   type level list, however order does not matter.
type family HasEffs xs f m

-- | Syntactic sugar for first order computations with no additional
--   constraints on the effectful context <tt>f</tt> or computational
--   context <tt>m</tt>.
--   
--   Example:
--   
--   <pre>
--   myFunction :: String -&gt; [Int] :+ '[MyEffect]
--   myFunction s = do
--     r1 &lt;- myMethod1 s
--     case r1 of
--       True -&gt; myMethod2 $ return 17
--       False -&gt; return [17]
--   </pre>
type (:+) v effs = forall m f. (HasEffs effs f m) => EffT f m v
infix 7 :+

-- | Combinator for composing effects.
data ( a :<> b ) (m :: * -> *)
(:<>) :: a m -> b m -> (:<>) a b
infixr 9 :<>
infixr 9 :<>

-- | Typeclass for extracting a specific effect from a larger context. It
--   should generally not be necessary to implement your own instances of
--   this class.
class Project (f :: (* -> *) -> *) g
prj :: Project f g => Lens' (f m) (g m)

-- | Helper for deriving Generic on effects with polymorphic methods
newtype HigherOrder n (m :: * -> *)
HigherOrder :: (forall a. n a -> m a) -> HigherOrder n
[applyHigherOrder] :: HigherOrder n -> forall a. n a -> m a
instance GHC.Generics.Generic ((Yael.Eff.:<>) a b m)
instance (GHC.Show.Show (a m), GHC.Show.Show (b m)) => GHC.Show.Show ((Yael.Eff.:<>) a b m)
instance Control.Monad.Trans.Control.MonadBaseControl s m => Control.Monad.Trans.Control.MonadBaseControl s (Yael.Eff.EffT f m)
instance Control.Monad.Base.MonadBase s m => Control.Monad.Base.MonadBase s (Yael.Eff.EffT f m)
instance GHC.Base.Alternative m => GHC.Base.Alternative (Yael.Eff.EffT f m)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Yael.Eff.EffT f m)
instance Control.Monad.Catch.MonadMask m => Control.Monad.Catch.MonadMask (Yael.Eff.EffT f m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (Yael.Eff.EffT f m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Yael.Eff.EffT f m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Yael.Eff.EffT f m)
instance GHC.Base.Monad m => GHC.Base.Monad (Yael.Eff.EffT f m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Yael.Eff.EffT f m)
instance GHC.Base.Functor m => GHC.Base.Functor (Yael.Eff.EffT f m)
instance (TypeError ...) => Yael.Eff.Project x y
instance Control.Lens.Tuple.Field1 ((Yael.Eff.:<>) a b m) ((Yael.Eff.:<>) a' b m) (a m) (a' m)
instance Control.Lens.Tuple.Field2 ((Yael.Eff.:<>) a b m) ((Yael.Eff.:<>) a b' m) (b m) (b' m)
instance Yael.Eff.Project (a Yael.Eff.:<> b) a
instance Yael.Eff.Project b c => Yael.Eff.Project (a Yael.Eff.:<> b) c
instance Yael.Eff.Project x x
instance Control.Monad.IO.Unlift.MonadUnliftIO m => Control.Monad.IO.Unlift.MonadUnliftIO (Yael.Eff.EffT f m)
instance Control.Monad.Trans.Class.MonadTrans (Yael.Eff.EffT f)

module Yael.Eff.Async
newtype Async m
Async :: (m () -> m ThreadId) -> Async m
[_async] :: Async m -> m () -> m ThreadId
async :: HasEff Async f m => EffT f m () -> EffT f m ThreadId
concurrentAsync :: MonadBaseControl IO m => Async m
noAsync :: (MonadIO m, Monad n) => m (Async n)

module Yael.Eff.Data
newtype Data a m
Data :: a -> Data a m
[_getData] :: Data a m -> a
getData :: HasEff (Data a) r m => EffT r m a
localData :: HasEff (Data a) r m => (a -> a) -> EffT r m x -> EffT r m x

module Yael.Eff.Error
data Error e m
Error :: (forall a. e -> m a) -> (forall a. m a -> (e -> m a) -> m a) -> Error e m
[_throw] :: Error e m -> forall a. e -> m a
[_catch] :: Error e m -> forall a. m a -> (e -> m a) -> m a
throw :: e -> a :+ '[Error e]
catch :: HasEff (Error e) f m => EffT f m a -> (e -> EffT f m a) -> EffT f m a
type UncheckedError = Error SomeException
mtlError :: MonadError e m => Error e m
exceptionError :: (Exception e, MonadThrow m, MonadCatch m) => Error e m
throwAny :: Exception e => e -> a :+ '[UncheckedError]
try :: HasEff (Error e) f m => EffT f m a -> EffT f m (Either e a)

module Yael.Eff.Log
newtype Log m
Log :: (String -> m ()) -> Log m
[_writeLog] :: Log m -> String -> m ()
writeLog :: String -> () :+ '[Log]
stdoutLog :: MonadIO m => Log m
handleLog :: MonadIO m => Handle -> Log m
noLog :: Monad m => Log m
withCollectLog :: (forall n. Monad n => Log n -> n a) -> (a, [String])

module Yael.Eff.Reader
data Reader r m
Reader :: m r -> (forall a. (r -> r) -> m a -> m a) -> Reader r m
[_ask] :: Reader r m -> m r
[_local] :: Reader r m -> forall a. (r -> r) -> m a -> m a
ask :: r :+ '[Reader r]
local :: HasEff (Reader r) f m => (r -> r) -> EffT f m a -> EffT f m a
mtlReader :: MonadReader r m => Reader r m

module Yael.Eff.State
data State s m
State :: m s -> (s -> m ()) -> State s m
[_get] :: State s m -> m s
[_put] :: State s m -> s -> m ()
get :: s :+ '[State s]
put :: s -> () :+ '[State s]
mtlState :: MonadState s m => State s m
ioRefState :: MonadIO m => IORef s -> State s m
withState :: s -> (forall n. Monad n => State s n -> n a) -> (a, s)
shareState :: Monad m => Lens' s s' -> State s m -> State s' m
