-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Partial types as a type constructor.
--   
--   Use the generic representation of an ADT to get a higher-kinded
--   data-style interface automatically.
@package higgledy
@version 0.3.1.0


module Data.Generic.HKD.Types

-- | Higher-kinded data (HKD) is the design pattern in which every field in
--   our type is wrapped in some functor <tt>f</tt>:
--   
--   <pre>
--   data User f
--    = User
--        { name :: f String
--        , age  :: f Int
--        }
--   </pre>
--   
--   Depending on the functor, we can get different behaviours: with
--   <a>Maybe</a>, we get a partial structure; with <tt>Validation</tt>, we
--   get a piecemeal validator; and so on. The <tt>HKD</tt> newtype allows
--   us to lift any type into an HKD-style API via its generic
--   representation.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDeriveGeneric -XTypeApplications
--   
--   &gt;&gt;&gt; :{
--   data User
--     = User { name :: String, age :: Int }
--     deriving Generic
--   :}
--   </pre>
--   
--   The <tt>HKD</tt> type is indexed by our choice of functor and the
--   structure we're lifting. In other words, we can define a synonym for
--   our behaviour:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Monoid (Last (..))
--   
--   &gt;&gt;&gt; type Partial a = HKD a Last
--   </pre>
--   
--   ... and then we're ready to go!
--   
--   <pre>
--   &gt;&gt;&gt; mempty @(Partial User)
--   User {name = Last {getLast = Nothing}, age = Last {getLast = Nothing}}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mempty @(HKD (Int, Bool) [])
--   (,) [] []
--   </pre>
newtype HKD (structure :: Type) (f :: Type -> Type)
HKD :: HKD_ f structure Void -> HKD
[runHKD] :: HKD -> HKD_ f structure Void

-- | Calculate the "partial representation" of a type.
type HKD_ (f :: Type -> Type) (structure :: Type) = GHKD_ f (Rep structure)

-- | Calculate the "partial representation" of a generic rep.
type family GHKD_ (f :: Type -> Type) (rep :: Type -> Type) = (output :: Type -> Type) | output -> f rep
class Tuple (f :: Type -> Type) (structure :: Type) (tuple :: Type) | f structure -> tuple
toTuple :: Tuple f structure tuple => HKD structure f -> tuple
fromTuple :: Tuple f structure tuple => tuple -> HKD structure f
instance Data.Generic.HKD.Types.GProductBC inner => Data.Generic.HKD.Types.GProductBC (GHC.Generics.M1 index meta inner)
instance (Data.Generic.HKD.Types.GProductBC left, Data.Generic.HKD.Types.GProductBC right) => Data.Generic.HKD.Types.GProductBC (left GHC.Generics.:*: right)
instance Data.Generic.HKD.Types.GProductBC (GHC.Generics.K1 index inner)
instance (Data.Barbie.Internal.Product.ProductB (Data.Generic.HKD.Types.HKD structure), Data.Barbie.Internal.Constraints.ConstraintsB (Data.Generic.HKD.Types.HKD structure), Data.Generic.HKD.Types.GProductBC (GHC.Generics.Rep structure)) => Data.Barbie.Internal.ProductC.ProductBC (Data.Generic.HKD.Types.HKD structure)
instance Data.Generic.HKD.Types.GConstraintsB inner => Data.Generic.HKD.Types.GConstraintsB (GHC.Generics.M1 index meta inner)
instance (Data.Generic.HKD.Types.GConstraintsB left, Data.Generic.HKD.Types.GConstraintsB right) => Data.Generic.HKD.Types.GConstraintsB (left GHC.Generics.:*: right)
instance Data.Generic.HKD.Types.GConstraintsB (GHC.Generics.K1 index inner)
instance (Data.Barbie.Internal.Functor.FunctorB (Data.Generic.HKD.Types.HKD structure), Data.Generic.HKD.Types.GConstraintsB (GHC.Generics.Rep structure), Data.Generic.HKD.Types.GAllBC (GHC.Generics.Rep structure)) => Data.Barbie.Internal.Constraints.ConstraintsB (Data.Generic.HKD.Types.HKD structure)
instance Data.Generic.HKD.Types.GAllBC inner => Data.Generic.HKD.Types.GAllBC (GHC.Generics.M1 index meta inner)
instance (Data.Generic.HKD.Types.GAllBC left, Data.Generic.HKD.Types.GAllBC right) => Data.Generic.HKD.Types.GAllBC (left GHC.Generics.:*: right)
instance Data.Generic.HKD.Types.GAllBC (GHC.Generics.K1 index inner)
instance Data.Generic.HKD.Types.GProductB inner => Data.Generic.HKD.Types.GProductB (GHC.Generics.M1 index meta inner)
instance (Data.Generic.HKD.Types.GProductB left, Data.Generic.HKD.Types.GProductB right) => Data.Generic.HKD.Types.GProductB (left GHC.Generics.:*: right)
instance Data.Generic.HKD.Types.GProductB (GHC.Generics.K1 index inner)
instance (Data.Barbie.Internal.Functor.FunctorB (Data.Generic.HKD.Types.HKD structure), Data.Generic.HKD.Types.GProductB (GHC.Generics.Rep structure)) => Data.Barbie.Internal.Product.ProductB (Data.Generic.HKD.Types.HKD structure)
instance Data.Generic.HKD.Types.GTraversableB inner => Data.Generic.HKD.Types.GTraversableB (GHC.Generics.M1 index meta inner)
instance (Data.Generic.HKD.Types.GTraversableB left, Data.Generic.HKD.Types.GTraversableB right) => Data.Generic.HKD.Types.GTraversableB (left GHC.Generics.:*: right)
instance Data.Generic.HKD.Types.GTraversableB (GHC.Generics.K1 index inner)
instance (Data.Barbie.Internal.Functor.FunctorB (Data.Generic.HKD.Types.HKD structure), Data.Generic.HKD.Types.GTraversableB (GHC.Generics.Rep structure)) => Data.Barbie.Internal.Traversable.TraversableB (Data.Generic.HKD.Types.HKD structure)
instance Data.Generic.HKD.Types.GFunctorB inner => Data.Generic.HKD.Types.GFunctorB (GHC.Generics.M1 index meta inner)
instance (Data.Generic.HKD.Types.GFunctorB left, Data.Generic.HKD.Types.GFunctorB right) => Data.Generic.HKD.Types.GFunctorB (left GHC.Generics.:*: right)
instance Data.Generic.HKD.Types.GFunctorB (GHC.Generics.K1 index inner)
instance Data.Generic.HKD.Types.GFunctorB (GHC.Generics.Rep structure) => Data.Barbie.Internal.Functor.FunctorB (Data.Generic.HKD.Types.HKD structure)
instance (Test.QuickCheck.Arbitrary.Arbitrary tuple, Data.Generic.HKD.Types.GToTuple (Data.Generic.HKD.Types.HKD_ f structure) tuple) => Test.QuickCheck.Arbitrary.Arbitrary (Data.Generic.HKD.Types.HKD structure f)
instance (Test.QuickCheck.Arbitrary.CoArbitrary tuple, Data.Generic.HKD.Types.GToTuple (Data.Generic.HKD.Types.HKD_ f structure) tuple) => Test.QuickCheck.Arbitrary.CoArbitrary (Data.Generic.HKD.Types.HKD structure f)
instance Data.Generic.HKD.Types.GToTuple inner tuple => Data.Generic.HKD.Types.GToTuple (GHC.Generics.M1 index meta inner) tuple
instance (Data.Generic.HKD.Types.GToTuple left left', Data.Generic.HKD.Types.GToTuple right right') => Data.Generic.HKD.Types.GToTuple (left GHC.Generics.:*: right) (left', right')
instance Data.Generic.HKD.Types.GToTuple (GHC.Generics.K1 index inner) inner
instance (GHC.Generics.Generic structure, Data.Generic.HKD.Types.GToTuple (Data.Generic.HKD.Types.HKD_ f structure) tuple) => Data.Generic.HKD.Types.Tuple f structure tuple
instance (GHC.Classes.Eq tuple, GHC.Generics.Generic xs, Data.Generic.HKD.Types.Tuple f xs tuple) => GHC.Classes.Eq (Data.Generic.HKD.Types.HKD xs f)
instance (GHC.Classes.Ord tuple, GHC.Generics.Generic xs, Data.Generic.HKD.Types.Tuple f xs tuple) => GHC.Classes.Ord (Data.Generic.HKD.Types.HKD xs f)
instance (GHC.Base.Semigroup tuple, GHC.Generics.Generic xs, Data.Generic.HKD.Types.Tuple f xs tuple) => GHC.Base.Semigroup (Data.Generic.HKD.Types.HKD xs f)
instance (GHC.Base.Monoid tuple, GHC.Generics.Generic xs, Data.Generic.HKD.Types.Tuple f xs tuple) => GHC.Base.Monoid (Data.Generic.HKD.Types.HKD xs f)
instance (GHC.Generics.Generic structure, Test.QuickCheck.Function.Function tuple, Data.Generic.HKD.Types.Tuple f structure tuple) => Test.QuickCheck.Function.Function (Data.Generic.HKD.Types.HKD structure f)
instance Data.Generic.HKD.Types.GShow named inner => Data.Generic.HKD.Types.GShow named (GHC.Generics.D1 meta inner)
instance (Data.Generic.HKD.Types.GShow 'GHC.Types.True inner, GHC.TypeLits.KnownSymbol name) => Data.Generic.HKD.Types.GShow any (GHC.Generics.C1 ('GHC.Generics.MetaCons name fixity 'GHC.Types.True) inner)
instance (Data.Generic.HKD.Types.GShow 'GHC.Types.False inner, GHC.TypeLits.KnownSymbol name) => Data.Generic.HKD.Types.GShow any (GHC.Generics.C1 ('GHC.Generics.MetaCons name fixity 'GHC.Types.False) inner)
instance (Data.Generic.HKD.Types.GShow 'GHC.Types.True left, Data.Generic.HKD.Types.GShow 'GHC.Types.True right) => Data.Generic.HKD.Types.GShow 'GHC.Types.True (left GHC.Generics.:*: right)
instance (Data.Generic.HKD.Types.GShow 'GHC.Types.False left, Data.Generic.HKD.Types.GShow 'GHC.Types.False right) => Data.Generic.HKD.Types.GShow 'GHC.Types.False (left GHC.Generics.:*: right)
instance (Data.Generic.HKD.Types.GShow 'GHC.Types.True inner, GHC.TypeLits.KnownSymbol field) => Data.Generic.HKD.Types.GShow 'GHC.Types.True (GHC.Generics.S1 ('GHC.Generics.MetaSel ('GHC.Maybe.Just field) i d c) inner)
instance Data.Generic.HKD.Types.GShow 'GHC.Types.False inner => Data.Generic.HKD.Types.GShow 'GHC.Types.False (GHC.Generics.S1 meta inner)
instance GHC.Show.Show (f inner) => Data.Generic.HKD.Types.GShow named (GHC.Generics.K1 GHC.Generics.R (f inner))
instance (GHC.Generics.Generic structure, Data.Generic.HKD.Types.GShow 'GHC.Types.True (Data.Generic.HKD.Types.HKD_ f structure)) => GHC.Show.Show (Data.Generic.HKD.Types.HKD structure f)
instance (Data.Functor.Contravariant.Contravariant (Data.Generic.HKD.Types.HKD_ f structure), GHC.Base.Functor (Data.Generic.HKD.Types.HKD_ f structure)) => GHC.Generics.Generic (Data.Generic.HKD.Types.HKD structure f)


module Data.Generic.HKD.Named

-- | The <a>record</a> function lets us supply arguments to a type one by
--   one, but can cause confusion when working with a record. If the record
--   contains two fields of the same type, for example, we've introduced an
--   opportunity for bugs and confusion. The <tt>record</tt> function uses
--   the wonderful <tt>named</tt> package to help us:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDeriveGeneric -XTypeApplications
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   data User
--     = User { name :: String, enemy :: String }
--     deriving Generic
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   test :: _
--   test = record @User
--   :}
--   ...
--   ... Found type wildcard ...
--   ... standing for ...("name" :! f [Char])
--   ...   -&gt; ("enemy" :! f [Char]) -&gt; HKD User f...
--   ...
--   </pre>
class Record (structure :: Type) (f :: Type -> Type) (k :: Type) | f structure -> k
record :: Record structure f k => k
instance Data.Generic.HKD.Named.GRecord inner f structure k => Data.Generic.HKD.Named.GRecord (GHC.Generics.D1 meta inner) f structure k
instance Data.Generic.HKD.Named.GRecord inner f structure k => Data.Generic.HKD.Named.GRecord (GHC.Generics.C1 meta inner) f structure k
instance (rec Data.Type.Equality.~ GHC.Generics.Rec0 inner, k Data.Type.Equality.~ ((name Named.Internal.:! inner) -> Data.Generic.HKD.Types.HKD structure f), meta Data.Type.Equality.~ 'GHC.Generics.MetaSel ('GHC.Maybe.Just name) i d c) => Data.Generic.HKD.Named.GRecord (GHC.Generics.S1 meta rec) f structure k
instance (Data.Generic.HKD.Named.GRecord right f structure k', rec Data.Type.Equality.~ GHC.Generics.Rec0 x, left Data.Type.Equality.~ GHC.Generics.S1 ('GHC.Generics.MetaSel ('GHC.Maybe.Just name) i d c) rec, k Data.Type.Equality.~ ((name Named.Internal.:! x) -> k')) => Data.Generic.HKD.Named.GRecord (left GHC.Generics.:*: right) f structure k
instance (Data.Functor.Contravariant.Contravariant (Data.Generic.HKD.Types.HKD_ f structure), GHC.Base.Functor (Data.Generic.HKD.Types.HKD_ f structure), list Data.Type.Equality.~ Data.Generic.HKD.Named.Rearrange (Data.Generic.HKD.Types.HKD_ f structure), Data.Generics.Product.Internal.Subtype.GUpcast list (Data.Generic.HKD.Types.HKD_ f structure), Data.Generic.HKD.Named.GRecord list f structure k) => Data.Generic.HKD.Named.Record structure f k

module Data.Generic.HKD.Labels

-- | For any record type, we can extract the labels generically using the
--   <a>Const</a> functor.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Generic.HKD
--   
--   &gt;&gt;&gt; import Data.Functor.Identity (Identity (..))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; data User = User { name :: String, age :: Int } deriving Generic
--   
--   &gt;&gt;&gt; label @User
--   User {name = Const "name", age = Const "age"}
--   </pre>
class Label (structure :: Type)
label :: Label structure => HKD structure (Const String)

-- | Because all HKD types are valid barbies, and we have the above
--   mechanism for extracting field names, we can ask some pretty
--   interesting questions.
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Lens
--   
--   &gt;&gt;&gt; import Data.Maybe (isNothing)
--   
--   &gt;&gt;&gt; import Data.Monoid (Last (..))
--   
--   &gt;&gt;&gt; import Data.Generic.HKD
--   </pre>
--   
--   Let's imagine, for example, that we're half way through filling in a
--   user's details:
--   
--   <pre>
--   &gt;&gt;&gt; data User = User { name :: String, age :: Int } deriving Generic
--   
--   &gt;&gt;&gt; test = mempty @(HKD User Last) &amp; field @"name" .~ pure "Tom"
--   </pre>
--   
--   We want to send a JSON response back to the client containing the
--   fields that have yet to be finished. All we need to do is pick the
--   fields where the values are <tt>Last Nothing</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; labelsWhere (isNothing . getLast) test
--   ["age"]
--   </pre>
labelsWhere :: forall structure f. (Label structure, ProductB (HKD structure), TraversableB (HKD structure)) => (forall a. f a -> Bool) -> HKD structure f -> [String]
instance Data.Generic.HKD.Labels.GLabels inner => Data.Generic.HKD.Labels.GLabels (GHC.Generics.D1 meta inner)
instance Data.Generic.HKD.Labels.GLabels inner => Data.Generic.HKD.Labels.GLabels (GHC.Generics.C1 ('GHC.Generics.MetaCons name fixity 'GHC.Types.True) inner)
instance (TypeError ...) => Data.Generic.HKD.Labels.GLabels (GHC.Generics.C1 ('GHC.Generics.MetaCons name fixity 'GHC.Types.False) inner)
instance GHC.TypeLits.KnownSymbol name => Data.Generic.HKD.Labels.GLabels (GHC.Generics.S1 ('GHC.Generics.MetaSel ('GHC.Maybe.Just name) i d c) (GHC.Generics.K1 index inner))
instance (Data.Generic.HKD.Labels.GLabels left, Data.Generic.HKD.Labels.GLabels right) => Data.Generic.HKD.Labels.GLabels (left GHC.Generics.:*: right)
instance (GHC.Generics.Generic structure, Data.Generic.HKD.Labels.GLabels (GHC.Generics.Rep structure)) => Data.Generic.HKD.Labels.Label structure


module Data.Generic.HKD.Construction

-- | When working with the HKD representation, it is useful to have a way
--   to convert to and from our original type. To do this, we can:
--   
--   <ul>
--   <li><tt>construct</tt> the original type from our HKD representation,
--   and</li>
--   <li><tt>deconstruct</tt> the original type <i>into</i> our HKD
--   representation.</li>
--   </ul>
--   
--   As an example, we can try (unsuccessfully) to construct an <tt>(Int,
--   Bool)</tt> tuple from an unpopulated partial structure.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; import Data.Monoid (Last)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; construct (mempty @(HKD (Int, Bool) Last))
--   Last {getLast = Nothing}
--   </pre>
--   
--   We can also <i>deconstruct</i> a tuple into a partial structure:
--   
--   <pre>
--   &gt;&gt;&gt; deconstruct @[] ("Hello", True)
--   (,) ["Hello"] [True]
--   </pre>
--   
--   These two methods also satisfy the round-tripping property:
--   
--   <pre>
--   construct (deconstruct x) == [ x :: (Int, Bool, String) ]
--   </pre>
class Construct (f :: Type -> Type) (structure :: Type)
construct :: Construct f structure => HKD structure f -> f structure
deconstruct :: Construct f structure => structure -> HKD structure f
instance (GHC.Base.Functor f, Data.Generic.HKD.Construction.GConstruct f inner) => Data.Generic.HKD.Construction.GConstruct f (GHC.Generics.M1 index meta inner)
instance (GHC.Base.Applicative f, Data.Generic.HKD.Construction.GConstruct f left, Data.Generic.HKD.Construction.GConstruct f right) => Data.Generic.HKD.Construction.GConstruct f (left GHC.Generics.:*: right)
instance GHC.Base.Applicative f => Data.Generic.HKD.Construction.GConstruct f (GHC.Generics.K1 index inner)
instance (GHC.Base.Applicative f, GHC.Generics.Generic structure, Data.Generic.HKD.Construction.GConstruct f (GHC.Generics.Rep structure)) => Data.Generic.HKD.Construction.Construct f structure


module Data.Generic.HKD.Build

-- | With many HKD applications, we're working with types like <a>Maybe</a>
--   where it makes sense for us to start with <a>mempty</a> and add values
--   in as we go.
--   
--   This isn't always the case, however: if all the component parts of our
--   type are gathered using some <a>IO</a> action, we'd like to construct
--   something like <tt>HKD MyType IO</tt>, and <tt>IO a</tt> isn't a
--   <a>Monoid</a> for all types <tt>a</tt>. When this happens, we need to
--   pass in our parameters <i>when</i> we build our structure.
--   
--   The <a>build</a> function lets us construct our type by passing
--   explicit values for each parameter:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDeriveGeneric -XTypeApplications
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   data User
--     = User { name :: String, age :: Int, likesDogs :: Bool }
--     deriving Generic
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   test :: _
--   test = build @User
--   :}
--   ...
--   ... Found type wildcard ...
--   ... standing for ...f [Char] -&gt; f Int -&gt; f Bool -&gt; HKD User f...
--   ...
--   </pre>
--   
--   Once we call the <a>build</a> function, and indicate the type we want
--   to build, we are free to pick whichever <tt>f</tt> we like and get to
--   work!
class Build (structure :: Type) (f :: Type -> Type) (k :: Type) | f structure -> k
build :: Build structure f k => k
instance Data.Generic.HKD.Build.GBuild f structure xs k => Data.Generic.HKD.Build.GBuild f structure (x : xs) (x -> k)
instance Data.Generic.HKD.Build.GBuild f structure '[] (Data.Generic.HKD.Types.HKD structure f)
instance (Data.Generic.HKD.Build.Fill f structure xs, Data.Generic.HKD.Build.GBuild f structure xs k) => Data.Generic.HKD.Build.Build structure f k
instance Data.Generic.HKD.Build.GFill f xs ys inner => Data.Generic.HKD.Build.GFill f xs ys (GHC.Generics.M1 index meta inner)
instance (Data.Generic.HKD.Build.GFill f xs ys left, Data.Generic.HKD.Build.GFill f ys zs right) => Data.Generic.HKD.Build.GFill f xs zs (left GHC.Generics.:*: right)
instance Data.Generic.HKD.Build.GFill f (f x : xs) xs (GHC.Generics.Rec0 x)
instance (GHC.Generics.Generic shape, Data.Generic.HKD.Build.GFill f with '[] (GHC.Generics.Rep shape)) => Data.Generic.HKD.Build.Fill f shape with


module Data.Generic.HKD

-- | Instances of this class provide means to talk about constraints, both
--   at compile-time, using <a>AllB</a>, and at run-time, in the form of
--   <a>Dict</a>, via <a>baddDicts</a>.
--   
--   A manual definition would look like this:
--   
--   <pre>
--   data T f = A (f <a>Int</a>) (f <a>String</a>) | B (f <a>Bool</a>) (f <a>Int</a>)
--   
--   instance <a>ConstraintsB</a> T where
--     type <a>AllB</a> c T = (c <a>Int</a>, c <a>String</a>, c <a>Bool</a>)
--   
--     <a>baddDicts</a> t = case t of
--       A x y -&gt; A (<a>Pair</a> <a>Dict</a> x) (<a>Pair</a> <a>Dict</a> y)
--       B z w -&gt; B (<a>Pair</a> <a>Dict</a> z) (<a>Pair</a> <a>Dict</a> w)
--   </pre>
--   
--   Now if we given a <tt>T f</tt>, we need to use the <a>Show</a>
--   instance of their fields, we can use:
--   
--   <pre>
--   <a>baddDicts</a> :: AllB Show b =&gt; b f -&gt; b (<a>Dict</a> <a>Show</a> <a>Product</a> b)
--   </pre>
--   
--   There is a default implementation of <a>ConstraintsB</a> for
--   <a>Generic</a> types, so in practice one will simply do:
--   
--   <pre>
--   derive instance <a>Generic</a> (T f)
--   instance <a>ConstraintsB</a> T
--   </pre>
class FunctorB b => ConstraintsB (b :: k -> Type -> Type) where {
    
    -- | <tt><a>AllB</a> c b</tt> should contain a constraint <tt>c a</tt> for
    --   each <tt>a</tt> occurring under an <tt>f</tt> in <tt>b f</tt>. E.g.:
    --   
    --   <pre>
    --   <a>AllB</a> <a>Show</a> Barbie ~ (<a>Show</a> <a>String</a>, <a>Show</a> <a>Int</a>)
    --   </pre>
    --   
    --   For requiring constraints of the form <tt>c (f a)</tt>, use
    --   <a>AllBF</a>.
    type family AllB (c :: k -> Constraint) (b :: k -> Type -> Type) :: Constraint;
}
baddDicts :: (ConstraintsB b, AllB c b) => b f -> b (Product (Dict c) f)

-- | Barbie-types that can be mapped over. Instances of <a>FunctorB</a>
--   should satisfy the following laws:
--   
--   <pre>
--   <a>bmap</a> <a>id</a> = <a>id</a>
--   <a>bmap</a> f . <a>bmap</a> g = <a>bmap</a> (f . g)
--   </pre>
--   
--   There is a default <a>bmap</a> implementation for <a>Generic</a>
--   types, so instances can derived automatically.
class FunctorB (b :: k -> Type -> Type)
bmap :: FunctorB b => (forall (a :: k). () => f a -> g a) -> b f -> b g

-- | Every type <tt>b</tt> that is an instance of both <a>ProductB</a> and
--   <a>ConstraintsB</a> can be made an instance of <a>ProductBC</a> as
--   well.
--   
--   Intuitively, in addition to <a>buniq</a> from <a>ProductB</a>, one can
--   define <a>buniqC</a> that takes into account constraints:
--   
--   <pre>
--   <a>buniq</a> :: (forall a . f a) -&gt; b f
--   <a>buniqC</a> :: <a>AllB</a> c b =&gt; (forall a . c a =&gt; f a) -&gt; b f
--   </pre>
--   
--   For technical reasons, <a>buniqC</a> is not currently provided as a
--   method of this class and is instead defined in terms <a>bdicts</a>,
--   which is similar to <a>baddDicts</a> but can produce the instance
--   dictionaries out-of-the-blue. <a>bdicts</a> could also be defined in
--   terms of <a>buniqC</a>, so they are essentially equivalent.
--   
--   <pre>
--   <a>bdicts</a> :: forall c b . <a>AllB</a> c b =&gt; b (<a>Dict</a> c)
--   <a>bdicts</a> = <a>buniqC</a> (<a>Dict</a> @c)
--   </pre>
--   
--   There is a default implementation for <a>Generic</a> types, so
--   instances can derived automatically.
class (ConstraintsB b, ProductB b) => ProductBC (b :: k -> Type -> Type)
bdicts :: (ProductBC b, AllB c b) => b (Dict c)

-- | Barbie-types that can be traversed from left to right. Instances
--   should satisfy the following laws:
--   
--   <pre>
--    t . <a>btraverse</a> f   = <a>btraverse</a> (t . f)  -- naturality
--   <a>btraverse</a> <a>Identity</a> = <a>Identity</a>           -- identity
--   <a>btraverse</a> (<a>Compose</a> . <a>fmap</a> g . f) = <a>Compose</a> . <a>fmap</a> (<a>btraverse</a> g) . <a>btraverse</a> f -- composition
--   </pre>
--   
--   There is a default <a>btraverse</a> implementation for <a>Generic</a>
--   types, so instances can derived automatically.
class FunctorB b => TraversableB (b :: k -> Type -> Type)
btraverse :: (TraversableB b, Applicative t) => (forall (a :: k). () => f a -> t (g a)) -> b f -> t (b g)

-- | Product types <i>without</i> named fields can't be addressed by field
--   name (for very obvious reason), so we instead need to address them
--   with their "position" index. This is a one-indexed type-applied
--   natural:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Lens ((^.))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t mempty @(HKD (Int, String) []) ^. position @1
--   mempty @(HKD (Int, String) []) ^. position @1 :: [Int]
--   </pre>
--   
--   As we're using the wonderful <tt>generic-lens</tt> library under the
--   hood, we also get some beautiful error messages when things go awry:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Generic.HKD.Construction
--   
--   &gt;&gt;&gt; deconstruct ("Hello", True) ^. position @4
--   ...
--   ... error:
--   ... The type HKD
--   ... ([Char], Bool) f does not contain a field at position 4
--   ...
--   </pre>
position :: forall index f structure inner. HasPosition' index (HKD structure f) (f inner) => Lens' (HKD structure f) (f inner)

-- | When we work with records, all the fields are named, and we can refer
--   to them using these names. This class provides a lens from our HKD
--   structure to any <tt>f</tt>-wrapped field.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDataKinds -XDeriveGeneric -XTypeApplications
--   
--   &gt;&gt;&gt; import Control.Lens ((&amp;), (.~))
--   
--   &gt;&gt;&gt; import Data.Monoid (Last)
--   
--   &gt;&gt;&gt; import GHC.Generics
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; data User = User { name :: String, age :: Int } deriving (Generic, Show)
--   
--   &gt;&gt;&gt; type Partial a = HKD a Last
--   </pre>
--   
--   We can create an empty partial <tt>User</tt> and set its name to "Tom"
--   (which, in this case, is <tt>pure "Tom" :: Last String</tt>):
--   
--   <pre>
--   &gt;&gt;&gt; mempty @(Partial User) &amp; field @"name" .~ pure "Tom"
--   User {name = Last {getLast = Just "Tom"}, age = Last {getLast = Nothing}}
--   </pre>
--   
--   Thanks to some <tt>generic-lens</tt> magic, we also get some pretty
--   magical type errors! If we create a (complete) partial user:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Generic.HKD.Construction (deconstruct)
--   
--   &gt;&gt;&gt; total = deconstruct @Last (User "Tom" 25)
--   </pre>
--   
--   ... and then try to access a field that isn't there, we get a friendly
--   message to point us in the right direction:
--   
--   <pre>
--   &gt;&gt;&gt; total &amp; field @"oops" .~ pure ()
--   ...
--   ... error:
--   ... The type HKD User Last does not contain a field named 'oops'.
--   ...
--   </pre>
field :: forall field f structure inner. HasField' field (HKD structure f) (f inner) => Lens' (HKD structure f) (f inner)
