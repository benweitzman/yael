-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generically derive traversals, lenses and prisms.
--   
--   This library uses GHC.Generics to derive efficient optics (traversals,
--   lenses and prisms) for algebraic data types in a type-directed way,
--   with a focus on good type inference and error messages when possible.
@package generic-lens
@version 1.1.0.0


-- | License : BSD3 Stability : experimental Portability : non-portable
--   
--   Generic representation of types with multiple parameters
module Data.Generics.Internal.GenericN
type family Param :: Nat -> k
newtype Rec (p :: Type) a x
Rec :: K1 R a x -> Rec a x
[unRec] :: Rec a x -> K1 R a x
class (Coercible (Rep a) (RepN a), Generic a) => GenericN (a :: Type) where {
    type family RepN (a :: Type) :: Type -> Type;
    type RepN a = Zip (Rep (Indexed a 0)) (Rep a);
}
toN :: GenericN a => RepN a x -> a
fromN :: GenericN a => a -> RepN a x
instance (GHC.Types.Coercible (GHC.Generics.Rep a) (Data.Generics.Internal.GenericN.RepN a), GHC.Generics.Generic a) => Data.Generics.Internal.GenericN.GenericN a


-- | Internal lens helpers. Only exported for Haddock
module Data.Generics.Internal.Profunctor.Prism
type APrism s t a b = Market a b a b -> Market a b s t
type Prism s t a b = forall p. (Choice p) => p a b -> p s t
type Prism' s a = forall p. (Choice p) => p a a -> p s s
left :: Prism ((a :+: c) x) ((b :+: c) x) (a x) (b x)
right :: Prism ((a :+: b) x) ((a :+: c) x) (b x) (c x)
prism :: (b -> t) -> (s -> Either t a) -> Prism s t a b
_Left :: Prism (Either a c) (Either b c) a b
_Right :: Prism (Either c a) (Either c b) a b
prismPRavel :: APrism s t a b -> Prism s t a b
build :: (Tagged b b -> Tagged t t) -> b -> t
match :: Prism s t a b -> s -> Either t a
without' :: Prism s t a b -> Prism s t c d -> Prism s t (Either a c) (Either b d)
withPrism :: APrism s t a b -> ((b -> t) -> (s -> Either t a) -> r) -> r
prism2prismp :: Market a b s t -> Prism s t a b
idPrism :: Market a b a b
gsum :: (a x -> c) -> (b x -> c) -> (a :+: b) x -> c
plus :: (a -> b) -> (c -> d) -> Either a c -> Either b d
data Market a b s t
Market :: (b -> t) -> (s -> Either t a) -> Market a b s t
instance GHC.Base.Functor (Data.Generics.Internal.Profunctor.Prism.Market a b s)
instance Data.Profunctor.Unsafe.Profunctor (Data.Generics.Internal.Profunctor.Prism.Market a b)
instance Data.Profunctor.Choice.Choice (Data.Generics.Internal.Profunctor.Prism.Market a b)


-- | Internal lens helpers. Only exported for Haddock
module Data.Generics.Internal.VL.Iso
data Exchange a b s t
Exchange :: (s -> a) -> (b -> t) -> Exchange a b s t
type Iso' s a = forall p f. (Profunctor p, Functor f) => p a (f a) -> p s (f s)
type Iso s t a b = forall p f. (Profunctor p, Functor f) => p a (f b) -> p s (f t)
fromIso :: Iso s t a b -> Iso b a t s

-- | Extract the two functions, one from <tt>s -&gt; a</tt> and one from
--   <tt>b -&gt; t</tt> that characterize an <a>Iso</a>.
withIso :: Iso s t a b -> ((s -> a) -> (b -> t) -> r) -> r

-- | A type and its generic representation are isomorphic
repIso :: (Generic a, Generic b) => Iso a b (Rep a x) (Rep b x)

-- | <a>M1</a> is just a wrapper around `f p`
mIso :: Iso (M1 i c f p) (M1 i c g p) (f p) (g p)
kIso :: Iso (K1 r a p) (K1 r b p) a b
recIso :: Iso (Rec r a p) (Rec r b p) a b
prodIso :: Iso ((a :*: b) x) ((a' :*: b') x) (a x, b x) (a' x, b' x)
iso :: (s -> a) -> (b -> t) -> Iso s t a b
instance GHC.Base.Functor (Data.Generics.Internal.VL.Iso.Exchange a b s)
instance Data.Profunctor.Unsafe.Profunctor (Data.Generics.Internal.VL.Iso.Exchange a b)


-- | Internal lens helpers. Only exported for Haddock
module Data.Generics.Internal.Profunctor.Iso
type Iso s t a b = forall p. (Profunctor p) => p a b -> p s t
type Iso' s a = Iso s s a a

-- | A type and its generic representation are isomorphic
repIso :: (Generic a, Generic b) => Iso a b (Rep a x) (Rep b x)

-- | <a>M1</a> is just a wrapper around `f p` mIso :: Iso' (M1 i c f p) (f
--   p)
mIso :: Iso (M1 i c f p) (M1 i c g p) (f p) (g p)
kIso :: Iso (K1 r a p) (K1 r b p) a b
recIso :: Iso (Rec r a p) (Rec r b p) a b
sumIso :: Iso ((a :+: b) x) ((a' :+: b') x) (Either (a x) (b x)) (Either (a' x) (b' x))
prodIso :: Iso ((a :*: b) x) ((a' :*: b') x) (a x, b x) (a' x, b' x)
assoc3 :: Iso ((a, b), c) ((a', b'), c') (a, (b, c)) (a', (b', c'))
fromIso :: Iso s t a b -> Iso b a t s
iso :: (s -> a) -> (b -> t) -> Iso s t a b
iso2isovl :: Iso s t a b -> Iso s t a b
withIso :: Iso s t a b -> ((s -> a) -> (b -> t) -> r) -> r
pairing :: Iso s t a b -> Iso s' t' a' b' -> Iso (s, s') (t, t') (a, a') (b, b')
data Exchange a b s t
Exchange :: (s -> a) -> (b -> t) -> Exchange a b s t
instance GHC.Base.Functor (Data.Generics.Internal.Profunctor.Iso.Exchange a b s)
instance Data.Profunctor.Unsafe.Profunctor (Data.Generics.Internal.Profunctor.Iso.Exchange a b)


-- | Internal lens helpers. Only exported for Haddock
module Data.Generics.Internal.Profunctor.Lens
type Lens s t a b = forall p. (Strong p) => p a b -> p s t
type LensLike p s t a b = p a b -> p s t
ravel :: (ALens a b a b -> ALens a b s t) -> Lens s t a b

-- | Setting
set :: ((a -> b) -> s -> t) -> (s, b) -> t
view :: Lens s s a a -> s -> a
withLensPrim :: Lens s t a b -> (forall c. (s -> (c, a)) -> ((c, b) -> t) -> r) -> r
idLens :: ALens a b a b

-- | Lens focusing on the first element of a product
first :: Lens ((a :*: b) x) ((a' :*: b) x) (a x) (a' x)

-- | Lens focusing on the second element of a product
second :: Lens ((a :*: b) x) ((a :*: b') x) (b x) (b' x)
fork :: (a -> b) -> (a -> c) -> a -> (b, c)
swap :: (a, b) -> (b, a)
cross :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
data Coyoneda f b
Coyoneda :: (a -> b) -> f a -> Coyoneda f b
inj :: Functor f => Coyoneda f a -> f a
proj :: Functor f => f a -> Coyoneda f a
newtype Alongside p s t a b
Alongside :: p (s, a) (t, b) -> Alongside p s t a b
[getAlongside] :: Alongside p s t a b -> p (s, a) (t, b)
(??) :: Functor f => f (a -> b) -> a -> f b
alongside :: Profunctor p => LensLike (Alongside p s' t') s t a b -> LensLike (Alongside p a b) s' t' a' b' -> LensLike p (s, s') (t, t') (a, a') (b, b')
assoc3L :: Lens ((a, b), c) ((a', b'), c') (a, (b, c)) (a', (b', c'))
stron :: (Either s s', b) -> Either (s, b) (s', b)
choosing :: forall s t a b s' t'. Lens s t a b -> Lens s' t' a b -> Lens (Either s s') (Either t t') a b
lens :: (s -> (c, a)) -> ((c, b) -> t) -> Lens s t a b
data ALens a b s t
ALens :: (s -> (c, a)) -> ((c, b) -> t) -> ALens a b s t
mLens :: Lens (M1 i c f p) (M1 i c g p) (f p) (g p)
repLens :: (Generic a, Generic b) => Lens a b (Rep a x) (Rep b x)
prodL :: Lens ((a :*: b) x) ((a' :*: b') x) (a x, b x) (a' x, b' x)
prodR :: Lens (a' x, b' x) (a x, b x) ((a' :*: b') x) ((a :*: b) x)
assoc3R :: Lens (a', (b', c')) (a, (b, c)) ((a', b'), c') ((a, b), c)
instance GHC.Base.Functor (Data.Generics.Internal.Profunctor.Lens.ALens a b s)
instance Data.Profunctor.Unsafe.Profunctor (Data.Generics.Internal.Profunctor.Lens.ALens a b)
instance Data.Profunctor.Strong.Strong (Data.Generics.Internal.Profunctor.Lens.ALens a b)
instance Data.Profunctor.Unsafe.Profunctor p => Data.Profunctor.Unsafe.Profunctor (Data.Generics.Internal.Profunctor.Lens.Alongside p c d)
instance Data.Profunctor.Strong.Strong p => Data.Profunctor.Strong.Strong (Data.Generics.Internal.Profunctor.Lens.Alongside p c d)
instance GHC.Base.Functor (Data.Generics.Internal.Profunctor.Lens.Coyoneda f)


-- | Internal lens helpers. Only exported for Haddock
module Data.Generics.Internal.VL.Lens

-- | Type alias for lens
type Lens' s a = Lens s s a a
type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
view :: ((a -> Const a a) -> s -> Const a s) -> s -> a

-- | Getting
(^.) :: s -> ((a -> Const a a) -> s -> Const a s) -> a
infixl 8 ^.
(.~) :: ((a -> Identity b) -> s -> Identity t) -> b -> s -> t
infixr 4 .~
set :: Lens s t a b -> b -> s -> t
over :: ((a -> Identity b) -> s -> Identity t) -> (a -> b) -> s -> t
lens2lensvl :: ALens a b s t -> Lens s t a b
ravel :: (ALens a b a b -> ALens a b s t) -> Lens s t a b
lens :: (s -> a) -> ((s, b) -> t) -> Lens s t a b


-- | Internal lens helpers. Only exported for Haddock
module Data.Generics.Internal.VL.Prism

-- | Type alias for prism
type Prism s t a b = forall p f. (Choice p, Applicative f) => p a (f b) -> p s (f t)
type Prism' s a = Prism s s a a
(^?) :: s -> ((a -> Const (First a) a) -> s -> Const (First a) s) -> Maybe a
infixl 8 ^?
match :: Prism s t a b -> s -> Either t a
(#) :: (Tagged b (Identity b) -> Tagged t (Identity t)) -> b -> t
prism :: (b -> t) -> (s -> Either t a) -> Prism s t a b
prismRavel :: (Market a b a b -> Market a b s t) -> Prism s t a b
type APrismVL s t a b = Market a b a (Identity b) -> Market a b s (Identity t)
withPrism :: APrismVL s t a b -> ((b -> t) -> (s -> Either t a) -> r) -> r
prism2prismvl :: Market a b s t -> Prism s t a b
build :: (Tagged b (Identity b) -> Tagged t (Identity t)) -> b -> t


-- | Internal lens helpers. Only exported for Haddock
module Data.Generics.Internal.VL.Traversal

-- | Type alias for traversal
type Traversal' s a = forall f. Applicative f => (a -> f a) -> s -> f s
type TraversalC (c :: * -> * -> Constraint) s t = forall f. Applicative f => (forall a b. c a b => a -> f b) -> s -> f t
type TraversalC' (c :: * -> Constraint) s = forall f. Applicative f => (forall a. c a => a -> f a) -> s -> f s
type Traversal s t a b = forall f. Applicative f => (a -> f b) -> s -> f t
type LensLikeC c f s = (forall a. c a => a -> f a) -> s -> f s
confusing :: Applicative f => Traversal s t a b -> (a -> f b) -> s -> f t
confusingC :: forall c f s. Applicative f => TraversalC' c s -> LensLikeC c f s
liftCurriedYoneda :: Applicative f => f a -> Curried (Yoneda f) a
yap :: Applicative f => Yoneda f (a -> b) -> f a -> Yoneda f b
newtype Curried f a
Curried :: (forall r. f (a -> r) -> f r) -> Curried f a
[runCurried] :: Curried f a -> forall r. f (a -> r) -> f r
liftCurried :: Applicative f => f a -> Curried f a
lowerCurried :: Applicative f => Curried f a -> f a
newtype Yoneda f a
Yoneda :: (forall b. (a -> b) -> f b) -> Yoneda f a
[runYoneda] :: Yoneda f a -> forall b. (a -> b) -> f b
liftYoneda :: Functor f => f a -> Yoneda f a
lowerYoneda :: Yoneda f a -> f a
instance GHC.Base.Functor (Data.Generics.Internal.VL.Traversal.Yoneda f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Data.Generics.Internal.VL.Traversal.Yoneda f)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Generics.Internal.VL.Traversal.Curried f)
instance GHC.Base.Functor f => GHC.Base.Applicative (Data.Generics.Internal.VL.Traversal.Curried f)


-- | Constrained traversals.
module Data.Generics.Product.Constraints
class HasConstraints (c :: * -> * -> Constraint) s t
constraints :: HasConstraints c s t => TraversalC c s t
class HasConstraints' (c :: * -> Constraint) s
constraints' :: HasConstraints' c s => TraversalC' c s
instance (GHC.Generics.Generic s, GHC.Generics.Generic t, Data.Generics.Product.Internal.Constraints.GHasConstraints c (GHC.Generics.Rep s) (GHC.Generics.Rep t)) => Data.Generics.Product.Constraints.HasConstraints c s t
instance (GHC.Generics.Generic s, Data.Generics.Product.Internal.Constraints.GHasConstraints' c (GHC.Generics.Rep s)) => Data.Generics.Product.Constraints.HasConstraints' c s


-- | Derive an isomorphism between a product type and a flat HList.
module Data.Generics.Product.HList
class IsList (f :: Type) (g :: Type) (as :: [Type]) (bs :: [Type]) | f -> as, g -> bs
list :: IsList f g as bs => Iso f g (HList as) (HList bs)
instance (GHC.Generics.Generic f, GHC.Generics.Generic g, Data.Generics.Product.Internal.HList.GIsList (GHC.Generics.Rep f) (GHC.Generics.Rep g) as bs) => Data.Generics.Product.HList.IsList f g as bs


-- | Derive record field getters and setters generically.
module Data.Generics.Product.Fields

-- | Records that have a field with a given name.
class HasField (field :: Symbol) s t a b | s field -> a, t field -> b, s field b -> t, t field a -> s

-- | A lens that focuses on a field with a given name. Compatible with the
--   lens package's <a>Lens</a> type.
--   
--   <pre>
--   &gt;&gt;&gt; human ^. field @"age"
--   50
--   </pre>
--   
--   <h3><i>Type changing</i></h3>
--   
--   <pre>
--   &gt;&gt;&gt; :t human
--   human :: Human Bool
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t human &amp; field @"other" .~ (42 :: Int)
--   human &amp; field @"other" .~ (42 :: Int) :: Human Int
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; human &amp; field @"other" .~ 42
--   Human {name = "Tunyasz", age = 50, address = "London", other = 42}
--   </pre>
--   
--   <h3><i>Type errors</i></h3>
--   
--   <pre>
--   &gt;&gt;&gt; human &amp; field @"weight" .~ 42
--   ...
--   ... The type Human Bool does not contain a field named 'weight'.
--   ...
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; human &amp; field @"address" .~ ""
--   ...
--   ... Not all constructors of the type Human Bool
--   ... contain a field named 'address'.
--   ... The offending constructors are:
--   ... HumanNoAddress
--   ...
--   </pre>
field :: HasField field s t a b => Lens s t a b
class HasField' (field :: Symbol) s a | s field -> a
field' :: HasField' field s a => Lens s s a a

-- | Records that have a field with a given name.
--   
--   This is meant to be more general than <a>HasField</a>, but that is not
--   quite the case due to the lack of functional dependencies.
--   
--   The types <tt>s</tt> and <tt>t</tt> must be applications of the same
--   type constructor. In contrast, <a>HasField</a> also requires the
--   parameters of that type constructor to have representational roles.
--   
--   One use case of <a>HasField_</a> over <a>HasField</a> is for records
--   defined with <tt>data instance</tt>.
class HasField_ (field :: Symbol) s t a b
field_ :: HasField_ field s t a b => Lens s t a b

-- | <pre>
--   &gt;&gt;&gt; getField @"age" human
--   50
--   </pre>
getField :: forall f a s. HasField' f s a => s -> a

-- | <pre>
--   &gt;&gt;&gt; setField @"age" 60 human
--   Human {name = "Tunyasz", age = 60, address = "London", other = False}
--   </pre>
setField :: forall f s a. HasField' f s a => a -> s -> s
instance (GHC.Generics.Generic s, Data.Generics.Product.Fields.ErrorUnless field s (Data.Generics.Internal.Families.Collect.CollectField field (GHC.Generics.Rep s)), Data.Generics.Product.Internal.GLens.GLens' (Data.Generics.Product.Fields.HasTotalFieldPSym field) (GHC.Generics.Rep s) a) => Data.Generics.Product.Fields.HasField' field s a
instance (GHC.Generics.Generic s, GHC.Generics.Generic t, Data.Generics.Product.Fields.ErrorUnless field s (Data.Generics.Internal.Families.Collect.CollectField field (GHC.Generics.Rep s)), Data.Generics.Internal.Families.Has.HasTotalFieldP field (GHC.Generics.Rep s) Data.Generics.Product.Fields.~~ 'GHC.Maybe.Just a, Data.Generics.Internal.Families.Has.HasTotalFieldP field (GHC.Generics.Rep t) Data.Generics.Product.Fields.~~ 'GHC.Maybe.Just b, Data.Generics.Internal.Families.Has.HasTotalFieldP field (GHC.Generics.Rep (Data.Generics.Internal.Families.Changing.Indexed s)) Data.Generics.Product.Fields.~~ 'GHC.Maybe.Just a', Data.Generics.Internal.Families.Has.HasTotalFieldP field (GHC.Generics.Rep (Data.Generics.Internal.Families.Changing.Indexed t)) Data.Generics.Product.Fields.~~ 'GHC.Maybe.Just b', t Data.Generics.Product.Fields.~~ Data.Generics.Internal.Families.Changing.Infer s a' b, s Data.Generics.Product.Fields.~~ Data.Generics.Internal.Families.Changing.Infer t b' a, Data.Generics.Product.Internal.GLens.GLens (Data.Generics.Product.Fields.HasTotalFieldPSym field) (GHC.Generics.Rep s) (GHC.Generics.Rep t) a b) => Data.Generics.Product.Fields.HasField field s t a b
instance (GHC.Generics.Generic s, GHC.Generics.Generic t, Data.Generics.Product.Fields.ErrorUnless field s (Data.Generics.Internal.Families.Collect.CollectField field (GHC.Generics.Rep s)), Data.Generics.Internal.Families.Has.HasTotalFieldP field (GHC.Generics.Rep s) Data.Generics.Product.Fields.~~ 'GHC.Maybe.Just a, Data.Generics.Internal.Families.Has.HasTotalFieldP field (GHC.Generics.Rep t) Data.Generics.Product.Fields.~~ 'GHC.Maybe.Just b, Data.Generics.Internal.Families.Changing.UnifyHead s t, Data.Generics.Internal.Families.Changing.UnifyHead t s, Data.Generics.Product.Internal.GLens.GLens (Data.Generics.Product.Fields.HasTotalFieldPSym field) (GHC.Generics.Rep s) (GHC.Generics.Rep t) a b) => Data.Generics.Product.Fields.HasField_ field s t a b
instance (GHC.Generics.Generic s, GHC.Generics.Generic t, Data.Generics.Product.Internal.GLens.GLens (Data.Generics.Product.Fields.HasTotalFieldPSym field) (GHC.Generics.Rep s) (GHC.Generics.Rep t) a b) => Data.Generics.Product.Fields.HasField0 field s t a b
instance forall k (a :: k) (b :: k). (a Data.Type.Equality.~ b) => a Data.Generics.Product.Fields.~~ b
instance Data.Generics.Product.Fields.HasField_ f (Data.Generics.Internal.Void.Void1 a) (Data.Generics.Internal.Void.Void1 b) a b
instance Data.Generics.Product.Fields.HasField f (Data.Generics.Internal.Void.Void1 a) (Data.Generics.Internal.Void.Void1 b) a b


-- | License : BSD3 Stability : experimental Portability : non-portable
--   
--   Derive traversal over type parameters
module Data.Generics.Product.Param
newtype Rec (p :: Type) a x
Rec :: K1 R a x -> Rec a x
class HasParam (p :: Nat) s t a b | p t a -> s, p s b -> t, p s -> a, p t -> b
param :: (HasParam p s t a b, Applicative g) => (a -> g b) -> s -> g t
instance Data.Generics.Product.Param.GHasParamRec (Data.Generics.Internal.Families.Changing.LookupParam si p) s t a b => Data.Generics.Product.Param.GHasParam p (Data.Generics.Internal.GenericN.Rec si s) (Data.Generics.Internal.GenericN.Rec ti t) a b
instance Data.Generics.Product.Param.GHasParamRec 'GHC.Maybe.Nothing a a c d
instance Data.Generics.Product.Param.HasParam n s t a b => Data.Generics.Product.Param.GHasParamRec ('GHC.Maybe.Just n) s t a b
instance (Data.Generics.Internal.GenericN.GenericN s, Data.Generics.Internal.GenericN.GenericN t, s Data.Type.Equality.~ Data.Generics.Internal.Families.Changing.Infer t (Data.Generics.Internal.Families.Changing.P n b 'Data.Generics.Internal.Families.Changing.PTag) a, t Data.Type.Equality.~ Data.Generics.Internal.Families.Changing.Infer s (Data.Generics.Internal.Families.Changing.P n a 'Data.Generics.Internal.Families.Changing.PTag) b, Data.Generics.Product.Param.Error (Data.Generics.Internal.Families.Changing.ArgCount s GHC.TypeNats.<=? n) n (Data.Generics.Internal.Families.Changing.ArgCount s) s, a Data.Type.Equality.~ Data.Generics.Internal.Families.Changing.ArgAt s n, b Data.Type.Equality.~ Data.Generics.Internal.Families.Changing.ArgAt t n, Data.Generics.Product.Param.GHasParam n (Data.Generics.Internal.GenericN.RepN s) (Data.Generics.Internal.GenericN.RepN t) a b) => Data.Generics.Product.Param.HasParam n s t a b
instance (Data.Generics.Product.Param.GHasParam p l l' a b, Data.Generics.Product.Param.GHasParam p r r' a b) => Data.Generics.Product.Param.GHasParam p (l GHC.Generics.:*: r) (l' GHC.Generics.:*: r') a b
instance (Data.Generics.Product.Param.GHasParam p l l' a b, Data.Generics.Product.Param.GHasParam p r r' a b) => Data.Generics.Product.Param.GHasParam p (l GHC.Generics.:+: r) (l' GHC.Generics.:+: r') a b
instance Data.Generics.Product.Param.GHasParam p GHC.Generics.U1 GHC.Generics.U1 a b
instance Data.Generics.Product.Param.GHasParam p s t a b => Data.Generics.Product.Param.GHasParam p (GHC.Generics.M1 m meta s) (GHC.Generics.M1 m meta t) a b
instance Data.Generics.Product.Param.GHasParam p (Data.Generics.Internal.GenericN.Rec (param p) a) (Data.Generics.Internal.GenericN.Rec (param p) b) a b
instance Data.Generics.Product.Param.HasParam p (Data.Generics.Internal.Void.Void1 a) (Data.Generics.Internal.Void.Void1 b) a b


-- | Derive positional product type getters and setters generically.
module Data.Generics.Product.Positions

-- | Records that have a field at a given position.
class HasPosition (i :: Nat) s t a b | s i -> a, t i -> b, s i b -> t, t i a -> s

-- | A lens that focuses on a field at a given position. Compatible with
--   the lens package's <a>Lens</a> type.
--   
--   <pre>
--   &gt;&gt;&gt; human ^. position @1
--   "Tunyasz"
--   
--   &gt;&gt;&gt; human &amp; position @3 .~ "Berlin"
--   Human {name = "Tunyasz", age = 50, address = "Berlin"}
--   </pre>
--   
--   <h3><i>Type errors</i></h3>
--   
--   <pre>
--   &gt;&gt;&gt; human &amp; position @4 .~ "Berlin"
--   ...
--   ... The type Human does not contain a field at position 4
--   ...
--   </pre>
position :: HasPosition i s t a b => Lens s t a b

-- | Records that have a field at a given position.
--   
--   The difference between <a>HasPosition</a> and <a>HasPosition_</a> is
--   similar to the one between <a>HasField</a> and <a>HasField_</a>. See
--   <a>HasField_</a>.
class HasPosition' (i :: Nat) s a | s i -> a
position' :: HasPosition' i s a => Lens s s a a
class HasPosition_ (i :: Nat) s t a b
position_ :: HasPosition_ i s t a b => Lens s t a b

-- | Records that have a field at a given position.
--   
--   This class gives the minimal constraints needed to define this lens.
--   For common uses, see <a>HasPosition</a>.
class HasPosition0 (i :: Nat) s t a b
position0 :: HasPosition0 i s t a b => Lens s t a b
getPosition :: forall i s a. HasPosition' i s a => s -> a
setPosition :: forall i s a. HasPosition' i s a => a -> s -> s
instance (GHC.Generics.Generic s, Data.Generics.Product.Positions.ErrorUnless i s ((0 Data.Generics.Product.Internal.Positions.<? i) Data.Type.Bool.&& (i GHC.TypeNats.<=? Data.Generics.Product.Internal.Positions.Size (GHC.Generics.Rep s))), cs Data.Type.Equality.~ Data.Generics.Product.Internal.Positions.CRep s, GHC.Types.Coercible (GHC.Generics.Rep s) cs, Data.Generics.Product.Internal.GLens.GLens' (Data.Generics.Product.Positions.HasTotalPositionPSym i) cs a) => Data.Generics.Product.Positions.HasPosition' i s a
instance (GHC.Generics.Generic s, GHC.Generics.Generic t, Data.Generics.Product.Positions.ErrorUnless i s ((0 Data.Generics.Product.Internal.Positions.<? i) Data.Type.Bool.&& (i GHC.TypeNats.<=? Data.Generics.Product.Internal.Positions.Size (GHC.Generics.Rep s))), Data.Generics.Product.Internal.GLens.GLens (Data.Generics.Product.Positions.HasTotalPositionPSym i) (Data.Generics.Product.Internal.Positions.CRep s) (Data.Generics.Product.Internal.Positions.CRep t) a b, Data.Generics.Internal.Families.Has.HasTotalPositionP i (Data.Generics.Product.Internal.Positions.CRep s) Data.Generics.Product.Positions.~~ 'GHC.Maybe.Just a, Data.Generics.Internal.Families.Has.HasTotalPositionP i (Data.Generics.Product.Internal.Positions.CRep t) Data.Generics.Product.Positions.~~ 'GHC.Maybe.Just b, Data.Generics.Internal.Families.Has.HasTotalPositionP i (Data.Generics.Product.Internal.Positions.CRep (Data.Generics.Internal.Families.Changing.Indexed s)) Data.Generics.Product.Positions.~~ 'GHC.Maybe.Just a', Data.Generics.Internal.Families.Has.HasTotalPositionP i (Data.Generics.Product.Internal.Positions.CRep (Data.Generics.Internal.Families.Changing.Indexed t)) Data.Generics.Product.Positions.~~ 'GHC.Maybe.Just b', t Data.Generics.Product.Positions.~~ Data.Generics.Internal.Families.Changing.Infer s a' b, s Data.Generics.Product.Positions.~~ Data.Generics.Internal.Families.Changing.Infer t b' a, GHC.Types.Coercible (Data.Generics.Product.Internal.Positions.CRep s) (GHC.Generics.Rep s), GHC.Types.Coercible (Data.Generics.Product.Internal.Positions.CRep t) (GHC.Generics.Rep t)) => Data.Generics.Product.Positions.HasPosition i s t a b
instance (GHC.Generics.Generic s, GHC.Generics.Generic t, Data.Generics.Product.Positions.ErrorUnless i s ((0 Data.Generics.Product.Internal.Positions.<? i) Data.Type.Bool.&& (i GHC.TypeNats.<=? Data.Generics.Product.Internal.Positions.Size (GHC.Generics.Rep s))), Data.Generics.Product.Internal.GLens.GLens (Data.Generics.Product.Positions.HasTotalPositionPSym i) (Data.Generics.Product.Internal.Positions.CRep s) (Data.Generics.Product.Internal.Positions.CRep t) a b, Data.Generics.Internal.Families.Changing.UnifyHead s t, Data.Generics.Internal.Families.Changing.UnifyHead t s, GHC.Types.Coercible (Data.Generics.Product.Internal.Positions.CRep s) (GHC.Generics.Rep s), GHC.Types.Coercible (Data.Generics.Product.Internal.Positions.CRep t) (GHC.Generics.Rep t)) => Data.Generics.Product.Positions.HasPosition_ i s t a b
instance (GHC.Generics.Generic s, GHC.Generics.Generic t, Data.Generics.Product.Internal.GLens.GLens (Data.Generics.Product.Positions.HasTotalPositionPSym i) (Data.Generics.Product.Internal.Positions.CRep s) (Data.Generics.Product.Internal.Positions.CRep t) a b, GHC.Types.Coercible (Data.Generics.Product.Internal.Positions.CRep s) (GHC.Generics.Rep s), GHC.Types.Coercible (Data.Generics.Product.Internal.Positions.CRep t) (GHC.Generics.Rep t)) => Data.Generics.Product.Positions.HasPosition0 i s t a b
instance forall k (a :: k) (b :: k). (a Data.Type.Equality.~ b) => a Data.Generics.Product.Positions.~~ b
instance Data.Generics.Product.Positions.HasPosition_ f (Data.Generics.Internal.Void.Void1 a) (Data.Generics.Internal.Void.Void1 b) a b
instance Data.Generics.Product.Positions.HasPosition f (Data.Generics.Internal.Void.Void1 a) (Data.Generics.Internal.Void.Void1 b) a b


-- | Structural subtype relationships between product types.
module Data.Generics.Product.Subtype

-- | Structural subtype relationship
--   
--   <tt>sub</tt> is a (structural) <tt>subtype</tt> of <tt>sup</tt>, if
--   its fields are a subset of those of <tt>sup</tt>.
class Subtype sup sub

-- | Structural subtype lens. Given a subtype relationship <tt>sub :&lt;
--   sup</tt>, we can focus on the <tt>sub</tt> structure of <tt>sup</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; human ^. super @Animal
--   Animal {name = "Tunyasz", age = 50}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set (super @Animal) (Animal "dog" 10) human
--   Human {name = "dog", age = 10, address = "London"}
--   </pre>
super :: Subtype sup sub => Lens sub sub sup sup

-- | Cast the more specific subtype to the more general supertype
--   
--   <pre>
--   &gt;&gt;&gt; upcast human :: Animal
--   Animal {name = "Tunyasz", age = 50}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; upcast (upcast human :: Animal) :: Human
--   ...
--   ... The type 'Animal' is not a subtype of 'Human'.
--   ... The following fields are missing from 'Animal':
--   ... address
--   ...
--   </pre>
upcast :: Subtype sup sub => sub -> sup

-- | Plug a smaller structure into a larger one
--   
--   <pre>
--   &gt;&gt;&gt; smash (Animal "dog" 10) human
--   Human {name = "dog", age = 10, address = "London"}
--   </pre>
smash :: Subtype sup sub => sup -> sub -> sub
instance (GHC.Generics.Generic a, GHC.Generics.Generic b, Data.Generics.Product.Internal.Subtype.GSmash (GHC.Generics.Rep a) (GHC.Generics.Rep b), Data.Generics.Product.Internal.Subtype.GUpcast (GHC.Generics.Rep a) (GHC.Generics.Rep b), Data.Generics.Product.Subtype.ErrorUnless b a (Data.Generics.Internal.Families.Collect.CollectFieldsOrdered (GHC.Generics.Rep b) Data.Generics.Internal.Families.Collect.\\ Data.Generics.Internal.Families.Collect.CollectFieldsOrdered (GHC.Generics.Rep a))) => Data.Generics.Product.Subtype.Subtype b a
instance Data.Generics.Product.Subtype.Subtype a Data.Generics.Internal.Void.Void
instance Data.Generics.Product.Subtype.Subtype Data.Generics.Internal.Void.Void a


-- | Derive lenses of a given type in a product.
module Data.Generics.Product.Typed

-- | Records that have a field with a unique type.
class HasType a s

-- | A lens that focuses on a field with a unique type in its parent type.
--   Compatible with the lens package's <a>Lens</a> type.
--   
--   <pre>
--   &gt;&gt;&gt; human ^. typed @Int
--   50
--   </pre>
--   
--   <h3><i>Type errors</i></h3>
--   
--   <pre>
--   &gt;&gt;&gt; human ^. typed @String
--   ...
--   ...
--   ... The type Human contains multiple values of type [Char].
--   ... The choice of value is thus ambiguous. The offending constructors are:
--   ... Human
--   ... HumanNoTall
--   ...
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; human ^. typed @Bool
--   ...
--   ...
--   ... Not all constructors of the type Human contain a field of type Bool.
--   ... The offending constructors are:
--   ... HumanNoTall
--   ...
--   </pre>
typed :: HasType a s => Lens s s a a

-- | Get field at type.
getTyped :: HasType a s => s -> a

-- | Set field at type.
setTyped :: HasType a s => a -> s -> s
instance (GHC.Generics.Generic s, Data.Generics.Product.Typed.ErrorUnlessOne a s (Data.Generics.Internal.Families.Collect.CollectTotalType a (GHC.Generics.Rep s)), Data.Generics.Product.Internal.GLens.GLens (Data.Generics.Product.Typed.HasTotalTypePSym a) (GHC.Generics.Rep s) (GHC.Generics.Rep s) a a) => Data.Generics.Product.Typed.HasType a s
instance Data.Generics.Product.Typed.HasType a Data.Generics.Internal.Void.Void


-- | Derive a variety of lenses generically.
module Data.Generics.Product.Any
class HasAny (sel :: k) s t a b | s sel k -> a

-- | A lens that focuses on a part of a product as identified by some
--   selector. Currently supported selectors are field names, positions and
--   unique types. Compatible with the lens package's <a>Lens</a> type.
--   
--   <pre>
--   &gt;&gt;&gt; human ^. the @Int
--   50
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; human ^. the @"name"
--   "Tunyasz"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; human ^. the @3
--   "London"
--   </pre>
the :: HasAny sel s t a b => Lens s t a b
instance Data.Generics.Product.Positions.HasPosition i s t a b => Data.Generics.Product.Any.HasAny i s t a b
instance Data.Generics.Product.Fields.HasField field s t a b => Data.Generics.Product.Any.HasAny field s t a b
instance (Data.Generics.Product.Typed.HasType a s, t Data.Type.Equality.~ s, a Data.Type.Equality.~ b) => Data.Generics.Product.Any.HasAny a s t a b


-- | Derive traversals of a given type in a product.
module Data.Generics.Product.Types
class HasTypes s a
types :: forall a s. HasTypes s a => Traversal' s a
type Interesting f a = Snd (Interesting' (Rep f) a '[f])
instance Data.Generics.Product.Types.HasTypes' (Data.Generics.Product.Types.Interesting s a) s a => Data.Generics.Product.Types.HasTypes s a
instance (Data.Generics.Product.Types.GHasTypes (GHC.Generics.Rep s) a, GHC.Generics.Generic s) => Data.Generics.Product.Types.HasTypes' 'GHC.Types.True s a
instance forall k (l :: k -> *) a (r :: k -> *). (Data.Generics.Product.Types.GHasTypes l a, Data.Generics.Product.Types.GHasTypes r a) => Data.Generics.Product.Types.GHasTypes (l GHC.Generics.:*: r) a
instance forall k (l :: k -> *) a (r :: k -> *). (Data.Generics.Product.Types.GHasTypes l a, Data.Generics.Product.Types.GHasTypes r a) => Data.Generics.Product.Types.GHasTypes (l GHC.Generics.:+: r) a
instance forall k (s :: k -> *) a m (meta :: GHC.Generics.Meta). Data.Generics.Product.Types.GHasTypes s a => Data.Generics.Product.Types.GHasTypes (GHC.Generics.M1 m meta s) a
instance Data.Generics.Product.Types.GHasTypes (GHC.Generics.Rec0 a) a
instance Data.Generics.Product.Types.HasTypes b a => Data.Generics.Product.Types.GHasTypes (GHC.Generics.Rec0 b) a
instance Data.Generics.Product.Types.GHasTypes GHC.Generics.U1 a
instance Data.Generics.Product.Types.GHasTypes GHC.Generics.V1 a
instance Data.Generics.Product.Types.HasTypes' 'GHC.Types.False s a
instance Data.Generics.Product.Types.HasTypes GHC.Types.Bool a
instance Data.Generics.Product.Types.HasTypes GHC.Types.Char a
instance Data.Generics.Product.Types.HasTypes GHC.Types.Double a
instance Data.Generics.Product.Types.HasTypes GHC.Types.Float a
instance Data.Generics.Product.Types.HasTypes GHC.Integer.Type.Integer a
instance Data.Generics.Product.Types.HasTypes GHC.Types.Ordering a
instance Data.Generics.Product.Types.HasTypes GHC.Types.Int a
instance Data.Generics.Product.Types.HasTypes GHC.Int.Int8 a
instance Data.Generics.Product.Types.HasTypes GHC.Int.Int16 a
instance Data.Generics.Product.Types.HasTypes GHC.Int.Int32 a
instance Data.Generics.Product.Types.HasTypes GHC.Int.Int64 a
instance Data.Generics.Product.Types.HasTypes GHC.Types.Word a
instance Data.Generics.Product.Types.HasTypes GHC.Word.Word8 a
instance Data.Generics.Product.Types.HasTypes GHC.Word.Word16 a
instance Data.Generics.Product.Types.HasTypes GHC.Word.Word32 a
instance Data.Generics.Product.Types.HasTypes GHC.Word.Word64 a


-- | Magic product operations using Generics
--   
--   These classes need not be instantiated manually, as GHC can
--   automatically prove valid instances via Generics. Only the
--   <tt>Generic</tt> class needs to be derived (see examples).
module Data.Generics.Product


-- | Derive constructor-name-based prisms generically.
module Data.Generics.Sum.Constructors

-- | Sums that have a constructor with a given name.
class AsConstructor (ctor :: Symbol) s t a b | ctor s -> a, ctor t -> b

-- | A prism that projects a named constructor from a sum. Compatible with
--   the lens package's <a>Prism</a> type.
--   
--   <pre>
--   &gt;&gt;&gt; dog ^? _Ctor @"Dog"
--   Just (MkDog {name = "Shep", age = 3, fieldA = 30})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dog ^? _Ctor @"Cat"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cat ^? _Ctor @"Cat"
--   Just ("Mog",5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _Ctor @"Cat" # ("Garfield", 6) :: Animal Int
--   Cat "Garfield" 6
--   </pre>
--   
--   <h3><i>Type errors</i></h3>
--   
--   <pre>
--   &gt;&gt;&gt; cat ^? _Ctor @"Turtle"
--   ...
--   ...
--   ... The type Animal Int does not contain a constructor named "Turtle"
--   ...
--   </pre>
_Ctor :: AsConstructor ctor s t a b => Prism s t a b

-- | Sums that have a constructor with a given name.
--   
--   The difference between <tt>HasConstructor</tt> and
--   <tt>HasConstructor_</tt> is similar to the one between <a>HasField</a>
--   and <a>HasField_</a>. See <a>HasField_</a>.
class AsConstructor_ (ctor :: Symbol) s t a b
_Ctor_ :: AsConstructor_ ctor s t a b => Prism s t a b
class AsConstructor' (ctor :: Symbol) s a | ctor s -> a
_Ctor' :: AsConstructor' ctor s a => Prism s s a a

-- | Sums that have a constructor with a given name.
--   
--   This class gives the minimal constraints needed to define this prism.
--   For common uses, see <tt>HasConstructor</tt>.
class AsConstructor0 (ctor :: Symbol) s t a b
_Ctor0 :: AsConstructor0 ctor s t a b => Prism s t a b
instance (GHC.Generics.Generic s, Data.Generics.Sum.Constructors.ErrorUnless ctor s (Data.Generics.Internal.Families.Has.HasCtorP ctor (GHC.Generics.Rep s)), Data.Generics.Sum.Internal.Constructors.GAsConstructor' ctor (GHC.Generics.Rep s) a) => Data.Generics.Sum.Constructors.AsConstructor' ctor s a
instance (GHC.Generics.Generic s, GHC.Generics.Generic t, Data.Generics.Sum.Constructors.ErrorUnless ctor s (Data.Generics.Internal.Families.Has.HasCtorP ctor (GHC.Generics.Rep s)), Data.Generics.Sum.Internal.Constructors.GAsConstructor' ctor (GHC.Generics.Rep s) a, Data.Generics.Sum.Internal.Constructors.GAsConstructor' ctor (GHC.Generics.Rep (Data.Generics.Internal.Families.Changing.Indexed s)) a', Data.Generics.Sum.Internal.Constructors.GAsConstructor ctor (GHC.Generics.Rep s) (GHC.Generics.Rep t) a b, t Data.Type.Equality.~ Data.Generics.Internal.Families.Changing.Infer s a' b, Data.Generics.Sum.Internal.Constructors.GAsConstructor' ctor (GHC.Generics.Rep (Data.Generics.Internal.Families.Changing.Indexed t)) b', s Data.Type.Equality.~ Data.Generics.Internal.Families.Changing.Infer t b' a) => Data.Generics.Sum.Constructors.AsConstructor ctor s t a b
instance (GHC.Generics.Generic s, GHC.Generics.Generic t, Data.Generics.Sum.Constructors.ErrorUnless ctor s (Data.Generics.Internal.Families.Has.HasCtorP ctor (GHC.Generics.Rep s)), Data.Generics.Sum.Internal.Constructors.GAsConstructor' ctor (GHC.Generics.Rep s) a, Data.Generics.Sum.Internal.Constructors.GAsConstructor' ctor (GHC.Generics.Rep (Data.Generics.Internal.Families.Changing.Indexed s)) a', Data.Generics.Sum.Internal.Constructors.GAsConstructor ctor (GHC.Generics.Rep s) (GHC.Generics.Rep t) a b, Data.Generics.Sum.Internal.Constructors.GAsConstructor' ctor (GHC.Generics.Rep (Data.Generics.Internal.Families.Changing.Indexed t)) b', Data.Generics.Internal.Families.Changing.UnifyHead s t, Data.Generics.Internal.Families.Changing.UnifyHead t s) => Data.Generics.Sum.Constructors.AsConstructor_ ctor s t a b
instance (GHC.Generics.Generic s, GHC.Generics.Generic t, Data.Generics.Sum.Internal.Constructors.GAsConstructor ctor (GHC.Generics.Rep s) (GHC.Generics.Rep t) a b) => Data.Generics.Sum.Constructors.AsConstructor0 ctor s t a b
instance Data.Generics.Sum.Constructors.AsConstructor_ ctor (Data.Generics.Internal.Void.Void1 a) (Data.Generics.Internal.Void.Void1 b) a b
instance Data.Generics.Sum.Constructors.AsConstructor ctor (Data.Generics.Internal.Void.Void1 a) (Data.Generics.Internal.Void.Void1 b) a b


-- | The library internals are exposed through this module. Please keep in
--   mind that everything here is subject to change irrespective of the the
--   version numbers.
module Data.GenericLens.Internal
type Indexed t = Indexed' t 0
type family Infer (s :: *) (a' :: *) (b :: *) :: *
data PTag
PTag :: PTag
type family P :: Nat -> k -> PTag -> k
type family LookupParam (a :: k) (p :: Nat) :: Maybe Nat
type family ArgAt (t :: k) (n :: Nat) :: j
type family ArgCount (t :: k) :: Nat

-- | Ensure that the types <tt>a</tt> and <tt>b</tt> are both applications
--   of the same constructor. The arguments may be different.
class UnifyHead (a :: k) (b :: k)
type family HasTotalFieldP (field :: Symbol) f :: Maybe Type
type family HasTotalTypeP (typ :: Type) f :: Maybe Type
type family HasTotalPositionP (pos :: Nat) f :: Maybe Type
data Pos (p :: Nat)
type family HasPartialTypeP a f :: Bool
type family HasCtorP (ctor :: Symbol) f :: Bool
type family GTypes (rep :: Type -> Type) :: [Type]
type family CollectTotalType t f :: TypeStat
type family CollectPartialType t f :: [Symbol]
type family CollectField t f :: TypeStat
type family CollectFieldsOrdered (r :: * -> *) :: [Symbol]
data TypeStat
TypeStat :: [Symbol] -> [Symbol] -> [Symbol] -> TypeStat
[_containsNone] :: TypeStat -> [Symbol]
[_containsMultiple] :: TypeStat -> [Symbol]
[_containsOne] :: TypeStat -> [Symbol]
type family (xs :: [Symbol]) \\ (ys :: [Symbol]) :: [Symbol]
infixr 5 \\
type family ShowSymbols (ctors :: [Symbol]) :: ErrorMessage
type Indexed t = Indexed' t 0
type family Infer (s :: *) (a' :: *) (b :: *) :: *
data PTag
PTag :: PTag
type family P :: Nat -> k -> PTag -> k
type family LookupParam (a :: k) (p :: Nat) :: Maybe Nat
type family ArgAt (t :: k) (n :: Nat) :: j
type family ArgCount (t :: k) :: Nat

-- | Ensure that the types <tt>a</tt> and <tt>b</tt> are both applications
--   of the same constructor. The arguments may be different.
class UnifyHead (a :: k) (b :: k)
type family CollectTotalType t f :: TypeStat
type family CollectPartialType t f :: [Symbol]
type family CollectField t f :: TypeStat
type family CollectFieldsOrdered (r :: * -> *) :: [Symbol]
data TypeStat
TypeStat :: [Symbol] -> [Symbol] -> [Symbol] -> TypeStat
[_containsNone] :: TypeStat -> [Symbol]
[_containsMultiple] :: TypeStat -> [Symbol]
[_containsOne] :: TypeStat -> [Symbol]
type family (xs :: [Symbol]) \\ (ys :: [Symbol]) :: [Symbol]
infixr 5 \\
type family HasTotalFieldP (field :: Symbol) f :: Maybe Type
type family HasTotalTypeP (typ :: Type) f :: Maybe Type
type family HasTotalPositionP (pos :: Nat) f :: Maybe Type
data Pos (p :: Nat)
type family HasPartialTypeP a f :: Bool
type family HasCtorP (ctor :: Symbol) f :: Bool
type family GTypes (rep :: Type -> Type) :: [Type]
data Void
data Void1 a
data Void2 a b

-- | As <tt>AsConstructor</tt> but over generic representations as defined
--   by <a>GHC.Generics</a>.
class GAsConstructor (ctor :: Symbol) s t a b | ctor s -> a, ctor t -> b
_GCtor :: GAsConstructor ctor s t a b => Prism (s x) (t x) a b
type GAsConstructor' ctor s a = GAsConstructor ctor s s a a

-- | As <tt>AsType</tt> but over generic representations as defined by
--   <a>GHC.Generics</a>.
class GAsType (f :: Type -> Type) (as :: [Type])
_GTyped :: GAsType f as => Prism (f x) (f x) (HList as) (HList as)

-- | As <tt>AsSubtype</tt> but over generic representations as defined by
--   <a>GHC.Generics</a>.
class GAsSubtype (subf :: Type -> Type) (supf :: Type -> Type)
_GSub :: GAsSubtype subf supf => Prism' (supf x) (subf x)
type x <? y = Not (y <=? x)
infixl 4 <?
type family Size f :: Nat

-- | In-order labeling of the generic tree with the field positions
--   
--   We replace the (K1 R a) nodes with (K1 (Pos n) a), where <tt>n</tt> is
--   the position of the field in question in the data type. This is
--   convenient, because we can reuse all the existing functions as long as
--   they are polymorphic in the first parameter of <a>K1</a>.
type family CRep (a :: Type) :: G
class GLens (pred :: Pred) (s :: Type -> Type) (t :: Type -> Type) a b | s pred -> a, t pred -> b
glens :: GLens pred s t a b => Lens (s x) (t x) a b
type GLens' pred s a = GLens pred s s a a
type TyFun a b = a -> b -> Type
type family Eval (f :: TyFun a b) (x :: a) :: b
class GUpcast (sub :: Type -> Type) (sup :: Type -> Type)
gupcast :: GUpcast sub sup => sub p -> sup p
class GSmash sub sup
gsmash :: GSmash sub sup => sup p -> sub p -> sub p
class GHasConstraints (c :: * -> * -> Constraint) s t
gconstraints :: GHasConstraints c s t => TraversalC c (s x) (t x)

-- | Constrained traversal.
class GHasConstraints' (c :: * -> Constraint) (f :: * -> *)
gconstraints' :: forall g x. (GHasConstraints' c f, Applicative g) => (forall a. c a => a -> g a) -> f x -> g (f x)
class GIsList (f :: Type -> Type) (g :: Type -> Type) (as :: [Type]) (bs :: [Type]) | f -> as, g -> bs, bs f -> g, as g -> f
glist :: GIsList f g as bs => Iso (f x) (g x) (HList as) (HList bs)
glistR :: GIsList f g as bs => Iso (HList bs) (HList as) (g x) (f x)
class IndexList (i :: Nat) as bs a b | i as -> a, i bs -> b, i as b -> bs, i bs a -> as
point :: IndexList i as bs a b => Lens (HList as) (HList bs) a b
data HList (as :: [Type])
[Nil] :: HList '[]
[:>] :: a -> HList as -> HList (a : as)
infixr 5 :>
type family (as :: [k]) ++ (bs :: [k]) :: [k]
class Elem (as :: [(k, Type)]) (key :: k) (i :: Nat) a | as key -> i a
class ListTuple (tuple :: Type) (as :: [Type]) | as -> tuple where {
    type family ListToTuple as :: Type;
}
tupled :: ListTuple tuple as => Iso' (HList as) tuple
tupleToList :: ListTuple tuple as => tuple -> HList as
listToTuple :: ListTuple tuple as => HList as -> tuple
type family TupleToList a


-- | Structural subtype relationships between sum types.
module Data.Generics.Sum.Subtype

-- | Structural subtyping between sums. A sum <tt>Sub</tt> is a subtype of
--   another sum <tt>Sup</tt> if a value of <tt>Sub</tt> can be given
--   (modulo naming of constructors) whenever a value of <tt>Sup</tt> is
--   expected. In the running example for instance,
--   <tt>FourLeggedAnimal</tt> is a subtype of <tt>Animal</tt> since a
--   value of the former can be given as a value of the latter (renaming
--   <tt>Dog4</tt> to <tt>Dog</tt> and <tt>Cat4</tt> to <tt>Cat</tt>).
class AsSubtype sub sup

-- | A prism that captures structural subtyping. Allows a substructure to
--   be injected (upcast) into a superstructure or a superstructure to be
--   downcast into a substructure (which may fail).
--   
--   <pre>
--   &gt;&gt;&gt; _Sub # dog4 :: Animal
--   Dog (MkDog {name = "Snowy", age = 4})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cat ^? _Sub :: Maybe FourLeggedAnimal
--   Just (Cat4 "Mog" 5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; duck ^? _Sub :: Maybe FourLeggedAnimal
--   Nothing
--   </pre>
_Sub :: AsSubtype sub sup => Prism' sup sub

-- | Injects a subtype into a supertype (upcast).
injectSub :: AsSubtype sub sup => sub -> sup

-- | Projects a subtype from a supertype (downcast).
projectSub :: AsSubtype sub sup => sup -> Maybe sub
instance (GHC.Generics.Generic sub, GHC.Generics.Generic sup, Data.Generics.Sum.Internal.Subtype.GAsSubtype (GHC.Generics.Rep sub) (GHC.Generics.Rep sup)) => Data.Generics.Sum.Subtype.AsSubtype sub sup
instance Data.Generics.Sum.Subtype.AsSubtype a Data.Generics.Internal.Void.Void
instance Data.Generics.Sum.Subtype.AsSubtype Data.Generics.Internal.Void.Void a


-- | Derive constructor-field-type-based prisms generically.
module Data.Generics.Sum.Typed

-- | Sums that have a constructor with a field of the given type.
class AsType a s

-- | A prism that projects a constructor uniquely identifiable by the type
--   of its field. Compatible with the lens package's <a>Prism</a> type.
--   
--   <pre>
--   &gt;&gt;&gt; dog ^? _Typed @Dog
--   Just (MkDog {name = "Shep", age = Age 3})
--   
--   &gt;&gt;&gt; cat ^? _Typed @(Name, Age)
--   Just ("Mog",Age 5)
--   
--   &gt;&gt;&gt; dog ^? _Typed @Age
--   ...
--   ...
--   ... The type Animal contains multiple constructors whose fields are of type Age.
--   ... The choice of constructor is thus ambiguous, could be any of:
--   ... Duck
--   ... Turtle
--   ...
--   </pre>
_Typed :: AsType a s => Prism' s a

-- | Inject by type.
injectTyped :: AsType a s => a -> s

-- | Project by type.
projectTyped :: AsType a s => s -> Maybe a
instance (GHC.Generics.Generic s, Data.Generics.Sum.Typed.ErrorUnlessOne a s (Data.Generics.Internal.Families.Collect.CollectPartialType as (GHC.Generics.Rep s)), as Data.Type.Equality.~ Data.Generics.Product.Internal.HList.TupleToList a, Data.Generics.Product.Internal.HList.ListTuple a as, Data.Generics.Sum.Internal.Typed.GAsType (GHC.Generics.Rep s) as) => Data.Generics.Sum.Typed.AsType a s
instance Data.Generics.Sum.Typed.AsType a Data.Generics.Internal.Void.Void
instance Data.Generics.Sum.Typed.AsType Data.Generics.Internal.Void.Void a


-- | Derive a variety of prisms generically.
module Data.Generics.Sum.Any

-- | Sums that have generic prisms.
class AsAny (sel :: k) a s | s sel k -> a

-- | A prism that projects a sum as identified by some selector. Currently
--   supported selectors are constructor names and unique types. Compatible
--   with the lens package's <a>Prism</a> type.
--   
--   <pre>
--   &gt;&gt;&gt; dog ^? _As @"Dog"
--   Just (MkDog {name = "Shep", age = 3})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dog ^? _As @Dog
--   Just (MkDog {name = "Shep", age = 3})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dog ^? _As @"Cat"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cat ^? _As @(Name, Age)
--   Just ("Mog",5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cat ^? _As @"Cat"
--   Just ("Mog",5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _As @"Cat" # ("Garfield", 6) :: Animal
--   Cat "Garfield" 6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; duck ^? _As @Age
--   Just 2
--   </pre>
_As :: AsAny sel a s => Prism s s a a
instance Data.Generics.Sum.Constructors.AsConstructor ctor s s a a => Data.Generics.Sum.Any.AsAny ctor a s
instance Data.Generics.Sum.Typed.AsType a s => Data.Generics.Sum.Any.AsAny a a s


-- | Magic sum operations using Generics
--   
--   These classes need not be instantiated manually, as GHC can
--   automatically prove valid instances via Generics. Only the
--   <tt>Generic</tt> class needs to be derived (see examples).
module Data.Generics.Sum


-- | Provides an (orphan) IsLabel instance for field lenses and constructor
--   prisms. Use at your own risk.
module Data.Generics.Labels

-- | <a>Field</a> is morally the same as <a>HasField</a>, but it is
--   constructed from an incoherent combination of <a>HasField</a> and
--   <a>HasField'</a>. In this way, it can be seamlessly used in the
--   <a>IsLabel</a> instance even when dealing with data types that don't
--   have <a>Field</a> instances (like data instances).
class Field name s t a b | s name -> a, t name -> b, s name b -> t, t name a -> s
fieldLens :: Field name s t a b => Lens s t a b
type Field' name s a = Field name s s a a

-- | <a>Constructor</a> is morally the same as <a>AsConstructor</a>, but it
--   is constructed from an incoherent combination of <a>AsConstructor</a>
--   and <a>AsConstructor'</a>. In this way, it can be seamlessly used in
--   the <a>IsLabel</a> instance even when dealing with data types that
--   don't have <a>Constructor</a> instances (like data instances).
class Constructor name s t a b | name s -> a, name t -> b
constructorPrism :: Constructor name s t a b => Prism s t a b
type Constructor' name s a = Constructor name s s a a
instance forall k1 k2 k3 (capital :: GHC.Types.Bool) (name :: GHC.Types.Symbol) (p :: k2 -> k3 -> *) (f :: k1 -> k3) (s :: k2) (t :: k1) (a :: k2) (b :: k1) pafb psft. (capital Data.Type.Equality.~ Data.Generics.Labels.BeginsWithCapital name, Data.Generics.Labels.IsLabelHelper capital name p f s t a b, pafb Data.Type.Equality.~ p a (f b), psft Data.Type.Equality.~ p s (f t)) => GHC.OverloadedLabels.IsLabel name (pafb -> psft)
instance forall k (f :: * -> *) (name :: k) s t a b. (GHC.Base.Functor f, Data.Generics.Labels.Field name s t a b) => Data.Generics.Labels.IsLabelHelper 'GHC.Types.False name (->) f s t a b
instance (GHC.Base.Applicative f, Data.Profunctor.Choice.Choice p, Data.Generics.Labels.Constructor name s t a b, name' Data.Type.Equality.~ GHC.TypeLits.AppendSymbol "_" name) => Data.Generics.Labels.IsLabelHelper 'GHC.Types.True name' p f s t a b
instance Data.Generics.Sum.Constructors.AsConstructor name s t a b => Data.Generics.Labels.Constructor name s t a b
instance Data.Generics.Sum.Constructors.AsConstructor' name s a => Data.Generics.Labels.Constructor name s s a a
instance Data.Generics.Product.Fields.HasField name s t a b => Data.Generics.Labels.Field name s t a b
instance Data.Generics.Product.Fields.HasField' name s a => Data.Generics.Labels.Field name s s a a


-- | Derive an isomorphism between a newtype and its wrapped type.
module Data.Generics.Wrapped

class Wrapped s t a b | s -> a, t -> b

wrappedIso :: Wrapped s t a b => Iso s t a b

wrappedTo :: forall s t a b. Wrapped s t a b => s -> a

wrappedFrom :: forall s t a b. Wrapped s t a b => b -> t

_Unwrapped :: Wrapped s t a b => Iso s t a b

_Wrapped :: Wrapped s t a b => Iso b a t s
instance (GHC.Generics.Generic s, GHC.Generics.Generic t, Data.Generics.Wrapped.GWrapped (GHC.Generics.Rep s) (GHC.Generics.Rep t) a b, Data.Generics.Internal.Families.Changing.UnifyHead s t, Data.Generics.Internal.Families.Changing.UnifyHead t s) => Data.Generics.Wrapped.Wrapped s t a b
instance Data.Generics.Wrapped.GWrapped s t a b => Data.Generics.Wrapped.GWrapped (GHC.Generics.M1 i k s) (GHC.Generics.M1 i k t) a b
instance (a Data.Type.Equality.~ c, b Data.Type.Equality.~ d) => Data.Generics.Wrapped.GWrapped (GHC.Generics.K1 i a) (GHC.Generics.K1 i b) c d
