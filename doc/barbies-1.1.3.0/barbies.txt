-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Classes for working with types that can change clothes.
--   
--   Types that are parametric on a functor are like Barbies that have an
--   outfit for each role. This package provides the basic abstractions to
--   work with them comfortably.
@package barbies
@version 1.1.3.0


-- | Generalize the standard two-functor <a>Product</a> to the product of
--   <tt>n</tt>-functors. Intuitively, this means:
--   
--   <pre>
--   <a>Product</a> f g a ~~ (f a, g a)
--   
--   <a>Prod</a> '[]        a ~~  Const () a
--   <a>Prod</a> '[f]       a ~~ (f a)
--   <a>Prod</a> '[f, g]    a ~~ (f a, g a)
--   <a>Prod</a> '[f, g, h] a ~~ (f a, g a, h a)
--       ⋮
--   </pre>
module Data.Functor.Prod

-- | Product of n functors.
data Prod :: [k -> Type] -> k -> Type
[Unit] :: Prod '[] a
[Cons] :: f a -> Prod fs a -> Prod (f : fs) a

-- | The unit of the product.
zeroTuple :: Prod '[] a

-- | Lift a functor to a 1-tuple.
oneTuple :: f a -> Prod '[f] a

-- | Conversion from a standard <a>Product</a>
fromProduct :: Product f g a -> Prod '[f, g] a

-- | Conversion to a standard <a>Product</a>
toProduct :: Prod '[f, g] a -> Product f g a

-- | Flat product of products.
prod :: Prod ls a -> Prod rs a -> Prod (ls ++ rs) a

-- | Like <a>uncurry</a> but using <a>Prod</a> instead of pairs. Can be
--   thought of as a family of functions:
--   
--   <pre>
--   <a>uncurryn</a> :: r a -&gt; <a>Prod</a> '[] a
--   <a>uncurryn</a> :: (f a -&gt; r a) -&gt; <a>Prod</a> '[f] a
--   <a>uncurryn</a> :: (f a -&gt; g a -&gt; r a) -&gt; <a>Prod</a> '[f, g] a
--   <a>uncurryn</a> :: (f a -&gt; g a -&gt; h a -&gt; r a) -&gt; <a>Prod</a> '[f, g, h] a
--           ⋮
--   </pre>
uncurryn :: Curried (Prod fs a -> r a) -> Prod fs a -> r a

-- | Type-level, poly-kinded, list-concatenation.
type family (++) l r :: [k]

-- | <tt><a>Prod</a> '[f, g, h] a -&gt; r</tt> is the type of the uncurried
--   form of a function <tt>f a -&gt; g a -&gt; h a -&gt; r</tt>.
--   <a>Curried</a> moves from the former to the later. E.g.
--   
--   <pre>
--   <a>Curried</a> (<a>Prod</a> '[]  a    -&gt; r) = r a
--   <a>Curried</a> (<a>Prod</a> '[f] a    -&gt; r) = f a -&gt; r a
--   <a>Curried</a> (<a>Prod</a> '[f, g] a -&gt; r) = f a -&gt; g a -&gt; r a
--   </pre>
type family Curried t
instance GHC.Base.Functor (Data.Functor.Prod.Prod '[])
instance (GHC.Base.Functor f, GHC.Base.Functor (Data.Functor.Prod.Prod fs)) => GHC.Base.Functor (Data.Functor.Prod.Prod (f : fs))
instance GHC.Base.Applicative (Data.Functor.Prod.Prod '[])
instance (GHC.Base.Applicative f, GHC.Base.Applicative (Data.Functor.Prod.Prod fs)) => GHC.Base.Applicative (Data.Functor.Prod.Prod (f : fs))
instance GHC.Base.Alternative (Data.Functor.Prod.Prod '[])
instance (GHC.Base.Alternative f, GHC.Base.Alternative (Data.Functor.Prod.Prod fs)) => GHC.Base.Alternative (Data.Functor.Prod.Prod (f : fs))
instance Data.Foldable.Foldable (Data.Functor.Prod.Prod '[])
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable (Data.Functor.Prod.Prod fs)) => Data.Foldable.Foldable (Data.Functor.Prod.Prod (f : fs))
instance Data.Traversable.Traversable (Data.Functor.Prod.Prod '[])
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable (Data.Functor.Prod.Prod fs)) => Data.Traversable.Traversable (Data.Functor.Prod.Prod (f : fs))
instance Data.Functor.Classes.Eq1 (Data.Functor.Prod.Prod '[])
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 (Data.Functor.Prod.Prod fs)) => Data.Functor.Classes.Eq1 (Data.Functor.Prod.Prod (f : fs))
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Functor.Prod.Prod '[] a)
instance (Data.Functor.Classes.Eq1 f, GHC.Classes.Eq a, Data.Functor.Classes.Eq1 (Data.Functor.Prod.Prod fs)) => GHC.Classes.Eq (Data.Functor.Prod.Prod (f : fs) a)
instance Data.Functor.Classes.Ord1 (Data.Functor.Prod.Prod '[])
instance (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 (Data.Functor.Prod.Prod fs)) => Data.Functor.Classes.Ord1 (Data.Functor.Prod.Prod (f : fs))
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Functor.Prod.Prod '[] a)
instance (Data.Functor.Classes.Ord1 f, GHC.Classes.Ord a, Data.Functor.Classes.Ord1 (Data.Functor.Prod.Prod fs)) => GHC.Classes.Ord (Data.Functor.Prod.Prod (f : fs) a)
instance Data.Functor.Classes.Show1 (Data.Functor.Prod.Prod '[])
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 (Data.Functor.Prod.Prod fs)) => Data.Functor.Classes.Show1 (Data.Functor.Prod.Prod (f : fs))
instance GHC.Show.Show a => GHC.Show.Show (Data.Functor.Prod.Prod '[] a)
instance (Data.Functor.Classes.Show1 f, GHC.Show.Show a, Data.Functor.Classes.Show1 (Data.Functor.Prod.Prod fs)) => GHC.Show.Show (Data.Functor.Prod.Prod (f : fs) a)


-- | Support for operating on Barbie-types with constrained functions.
--   
--   Consider the following function:
--   
--   <pre>
--   showIt :: <a>Show</a> a =&gt; <a>Maybe</a> a -&gt; <a>Const</a> <a>String</a> a
--   showIt = <a>Const</a> . <a>show</a>
--   </pre>
--   
--   We would then like to be able to do:
--   
--   <pre>
--   <a>bmap</a> <tt>showIt</tt> :: <a>FunctorB</a> b =&gt; b <a>Maybe</a> -&gt; b (<a>Const</a> <a>String</a>)
--   </pre>
--   
--   This however doesn't work because of the <tt>(<a>Show</a> a)</tt>
--   constraint in the the type of <tt>showIt</tt>.
--   
--   This module adds support to overcome this problem.
module Data.Barbie.Constraints

-- | <tt><a>Dict</a> c a</tt> is evidence that there exists an instance of
--   <tt>c a</tt>.
--   
--   It is essentially equivalent to <tt>Dict (c a)</tt> from the
--   <a>constraints</a> package, but because of its kind, it allows us to
--   define things like <tt><a>Dict</a> <a>Show</a></tt>.
data Dict c a
[Dict] :: c a => Dict c a

-- | Turn a constrained-function into an unconstrained one that uses the
--   packed instance dictionary instead.
requiringDict :: (c a => r) -> Dict c a -> r

-- | Instances of this class provide means to talk about constraints, both
--   at compile-time, using <a>AllB</a>, and at run-time, in the form of
--   <a>Dict</a>, via <a>baddDicts</a>.
--   
--   A manual definition would look like this:
--   
--   <pre>
--   data T f = A (f <a>Int</a>) (f <a>String</a>) | B (f <a>Bool</a>) (f <a>Int</a>)
--   
--   instance <a>ConstraintsB</a> T where
--     type <a>AllB</a> c T = (c <a>Int</a>, c <a>String</a>, c <a>Bool</a>)
--   
--     <a>baddDicts</a> t = case t of
--       A x y -&gt; A (<a>Pair</a> <a>Dict</a> x) (<a>Pair</a> <a>Dict</a> y)
--       B z w -&gt; B (<a>Pair</a> <a>Dict</a> z) (<a>Pair</a> <a>Dict</a> w)
--   </pre>
--   
--   Now if we given a <tt>T f</tt>, we need to use the <a>Show</a>
--   instance of their fields, we can use:
--   
--   <pre>
--   <a>baddDicts</a> :: AllB Show b =&gt; b f -&gt; b (<a>Dict</a> <a>Show</a> <a>Product</a> b)
--   </pre>
--   
--   There is a default implementation of <a>ConstraintsB</a> for
--   <a>Generic</a> types, so in practice one will simply do:
--   
--   <pre>
--   derive instance <a>Generic</a> (T f)
--   instance <a>ConstraintsB</a> T
--   </pre>
class FunctorB b => ConstraintsB (b :: (k -> *) -> *) where {
    
    -- | <tt><a>AllB</a> c b</tt> should contain a constraint <tt>c a</tt> for
    --   each <tt>a</tt> occurring under an <tt>f</tt> in <tt>b f</tt>. E.g.:
    --   
    --   <pre>
    --   <a>AllB</a> <a>Show</a> Barbie ~ (<a>Show</a> <a>String</a>, <a>Show</a> <a>Int</a>)
    --   </pre>
    --   
    --   For requiring constraints of the form <tt>c (f a)</tt>, use
    --   <a>AllBF</a>.
    type family AllB (c :: k -> Constraint) b :: Constraint;
    type AllB c b = GAllB c (GAllBRep b);
}
baddDicts :: forall c f. (ConstraintsB b, AllB c b) => b f -> b (Dict c `Product` f)
baddDicts :: forall c f. (ConstraintsB b, CanDeriveConstraintsB c b f, AllB c b) => b f -> b (Dict c `Product` f)

-- | Every type <tt>b</tt> that is an instance of both <a>ProductB</a> and
--   <a>ConstraintsB</a> can be made an instance of <a>ProductBC</a> as
--   well.
--   
--   Intuitively, in addition to <a>buniq</a> from <a>ProductB</a>, one can
--   define <a>buniqC</a> that takes into account constraints:
--   
--   <pre>
--   <a>buniq</a> :: (forall a . f a) -&gt; b f
--   <a>buniqC</a> :: <a>AllB</a> c b =&gt; (forall a . c a =&gt; f a) -&gt; b f
--   </pre>
--   
--   For technical reasons, <a>buniqC</a> is not currently provided as a
--   method of this class and is instead defined in terms <a>bdicts</a>,
--   which is similar to <a>baddDicts</a> but can produce the instance
--   dictionaries out-of-the-blue. <a>bdicts</a> could also be defined in
--   terms of <a>buniqC</a>, so they are essentially equivalent.
--   
--   <pre>
--   <a>bdicts</a> :: forall c b . <a>AllB</a> c b =&gt; b (<a>Dict</a> c)
--   <a>bdicts</a> = <a>buniqC</a> (<a>Dict</a> @c)
--   </pre>
--   
--   There is a default implementation for <a>Generic</a> types, so
--   instances can derived automatically.
class (ConstraintsB b, ProductB b) => ProductBC (b :: (k -> Type) -> Type)
bdicts :: (ProductBC b, AllB c b) => b (Dict c)
bdicts :: (ProductBC b, CanDeriveProductBC c b, AllB c b) => b (Dict c)

-- | Like <a>bmap</a> but a constraint is allowed to be required on each
--   element of <tt>b</tt>
--   
--   E.g. If all fields of <tt>b</tt> are <a>Show</a>able then you could
--   store each shown value in it's slot using <a>Const</a>:
--   
--   <pre>
--   showFields :: (AllB Show b, ConstraintsB b) =&gt; b Identity -&gt; b (Const String)
--   showFields = bmapC @Show showField
--     where
--       showField :: forall a. Show a =&gt; Identity a -&gt; Const String a
--       showField (Identity a) = Const (show a)
--   </pre>
bmapC :: forall c b f g. (AllB c b, ConstraintsB b) => (forall a. c a => f a -> g a) -> b f -> b g

-- | Like <a>btraverse</a> but with a constraint on the elements of
--   <tt>b</tt>.
btraverseC :: forall c b f g h. (TraversableB b, ConstraintsB b, AllB c b, Applicative g) => (forall a. c a => f a -> g (h a)) -> b f -> g (b h)

-- | Similar to <a>AllB</a> but will put the functor argument <tt>f</tt>
--   between the constraint <tt>c</tt> and the type <tt>a</tt>. For
--   example:
--   
--   <pre>
--   <a>AllB</a>  <a>Show</a>   Barbie ~ (<a>Show</a>    <a>String</a>,  <a>Show</a>    <a>Int</a>)
--   <a>AllBF</a> <a>Show</a> f Barbie ~ (<a>Show</a> (f <a>String</a>), <a>Show</a> (f <a>Int</a>))
--   
--   </pre>
type AllBF c f b = AllB (ClassF c f) b

-- | <a>ClassF</a> has one universal instance that makes <tt><a>ClassF</a>
--   c f a</tt> equivalent to <tt>c (f a)</tt>. However, we have
--   
--   <pre>
--   'ClassF c f :: k -&gt; <tt>Constraint</tt>
--   </pre>
--   
--   This is useful since it allows to define constraint-constructors like
--   <tt><a>ClassF</a> <a>Monoid</a> <a>Maybe</a></tt>
class c (f a) => ClassF c f a

-- | Like <a>ClassF</a> but for binary relations.
class c (f a) (g a) => ClassFG c f g a

-- | <i>Deprecated: Renamed to AllBF (now based on AllB)</i>
type ConstraintsOf c f b = AllBF c f b

-- | <i>Deprecated: Renamed to baddDicts</i>
adjProof :: forall b c f. (ConstraintsB b, AllB c b) => b f -> b (Dict c `Product` f)

-- | <i>Deprecated: Class was renamed to ProductBC</i>
type ProofB b = ProductBC b


-- | Sometimes one needs a type like <tt>Barbie <a>Identity</a></tt> and it
--   may feel like a second-class record type, where one needs to unpack
--   values in each field. For those cases, we can leverage on closed
--   type-families:
--   
--   <pre>
--   data <a>Bare</a>
--   data <a>Covered</a>
--   
--   type family <a>Wear</a> t f a where
--     <a>Wear</a> <a>Bare</a>    f a = a
--     <a>Wear</a> <a>Covered</a> f a = f a
--   
--   data SignUpForm t f
--     = SignUpForm'
--         { username  :: <a>Wear</a> t f <a>String</a>,
--         , password  :: <a>Wear</a> t f <a>String</a>
--         , mailingOk :: <a>Wear</a> t f <a>Bool</a>
--         }
--    instance <tt>FunctorB</tt> (SignUpForm <a>Covered</a>)
--    instance <tt>TraversableB</tt> (SignUpForm <a>Covered</a>)
--    ...,
--    instance <a>BareB</a> SignUpForm
--   
--   type SignUpRaw  = SignUpForm <a>Maybe</a>
--   type SignUpData = SignUpForm <a>Bare</a>
--   
--   formData = SignUpForm "jbond" "shaken007" False :: SignUpData
--   </pre>
module Data.Barbie.Bare

-- | The <a>Wear</a> type-function allows one to define a Barbie-type as
--   
--   <pre>
--   data B t f
--     = B { f1 :: <a>Wear</a> t f <a>Int</a>
--         , f2 :: <a>Wear</a> t f <a>Bool</a>
--         }
--   </pre>
--   
--   This gives rise to two rather different types:
--   
--   <ul>
--   <li><tt>B <a>Covered</a> f</tt> is a normal Barbie-type, in the sense
--   that <tt>f1 :: B <a>Covered</a> f -&gt; f <a>Int</a></tt>, etc.</li>
--   <li><tt>B <a>Bare</a> f</tt>, on the other hand, is a normal record
--   with no functor around the type:</li>
--   </ul>
--   
--   <pre>
--   B { f1 :: 5, f2 = <a>True</a> } :: B <a>Bare</a> f
--   </pre>
type family Wear t f a
data Bare
data Covered

-- | Class of Barbie-types defined using <a>Wear</a> and can therefore have
--   <a>Bare</a> versions. Must satisfy:
--   
--   <pre>
--   <a>bcover</a> . <a>bstrip</a> = <a>id</a>
--   <a>bstrip</a> . <a>bcover</a> = <a>id</a>
--   </pre>
class FunctorB (b Covered) => BareB b
bstrip :: BareB b => b Covered Identity -> b Bare Identity
bcover :: BareB b => b Bare Identity -> b Covered Identity
bstrip :: (BareB b, CanDeriveBareB b) => b Covered Identity -> b Bare Identity
bcover :: (BareB b, CanDeriveBareB b) => b Bare Identity -> b Covered Identity

-- | Generalization of <a>bstrip</a> to arbitrary functors
bstripFrom :: BareB b => (forall a. f a -> a) -> b Covered f -> b Bare Identity

-- | Generalization of <a>bcover</a> to arbitrary functors
bcoverWith :: BareB b => (forall a. a -> f a) -> b Bare Identity -> b Covered f

module Data.Barbie.Internal

-- | Default implementation of <a>bmap</a> based on <a>Generic</a>.
gbmapDefault :: CanDeriveFunctorB b f g => (forall a. f a -> g a) -> b f -> b g
class GFunctorB f g repbf repbg
gbmap :: GFunctorB f g repbf repbg => (forall a. f a -> g a) -> repbf x -> repbg x

-- | <tt><a>CanDeriveFunctorB</a> B f g</tt> is in practice a predicate
--   about <tt>B</tt> only. Intuitively, it says that the following holds,
--   for any arbitrary <tt>f</tt>:
--   
--   <ul>
--   <li>There is an instance of <tt><a>Generic</a> (B f)</tt>.</li>
--   <li><tt>B f</tt> can contain fields of type <tt>b f</tt> as long as
--   there exists a <tt><a>FunctorB</a> b</tt> instance. In particular,
--   recursive usages of <tt>B f</tt> are allowed.</li>
--   <li><tt>B f</tt> can also contain usages of <tt>b f</tt> under a
--   <tt><a>Functor</a> h</tt>. For example, one could use <tt><a>Maybe</a>
--   (B f)</tt> when defining <tt>B f</tt>.</li>
--   </ul>
type CanDeriveFunctorB b f g = (GenericN (b f), GenericN (b g), GFunctorB f g (RepN (b f)) (RepN (b g)))

-- | Default implementation of <a>btraverse</a> based on <a>Generic</a>.
gbtraverseDefault :: forall b f g t. (Applicative t, CanDeriveTraversableB b f g) => (forall a. f a -> t (g a)) -> b f -> t (b g)
class GTraversableB f g repbf repbg
gbtraverse :: (GTraversableB f g repbf repbg, Applicative t) => (forall a. f a -> t (g a)) -> repbf x -> t (repbg x)

-- | <tt><a>CanDeriveTraversableB</a> B f g</tt> is in practice a predicate
--   about <tt>B</tt> only. It is analogous to <a>CanDeriveFunctorB</a>, so
--   it essentially requires the following to hold, for any arbitrary
--   <tt>f</tt>:
--   
--   <ul>
--   <li>There is an instance of <tt><a>Generic</a> (B f)</tt>.</li>
--   <li><tt>B f</tt> can contain fields of type <tt>b f</tt> as long as
--   there exists a <tt><a>TraversableB</a> b</tt> instance. In particular,
--   recursive usages of <tt>B f</tt> are allowed.</li>
--   <li><tt>B f</tt> can also contain usages of <tt>b f</tt> under a
--   <tt><a>Traversable</a> h</tt>. For example, one could use
--   <tt><a>Maybe</a> (B f)</tt> when defining <tt>B f</tt>.</li>
--   </ul>
type CanDeriveTraversableB b f g = (GenericN (b f), GenericN (b g), GTraversableB f g (RepN (b f)) (RepN (b g)))
gbuniqDefault :: forall b f. CanDeriveProductB b f f => (forall a. f a) -> b f

-- | Default implementation of <a>bprod</a> based on <a>Generic</a>.
gbprodDefault :: forall b f g. CanDeriveProductB b f g => b f -> b g -> b (f `Product` g)
class GProductB (f :: k -> *) (g :: k -> *) repbf repbg repbfg
gbprod :: GProductB f g repbf repbg repbfg => repbf x -> repbg x -> repbfg x
gbuniq :: GProductB f g repbf repbg repbfg => (forall a. f a) -> repbf x

-- | <tt><a>CanDeriveProductB</a> B f g</tt> is in practice a predicate
--   about <tt>B</tt> only. Intuitively, it says that the following holds,
--   for any arbitrary <tt>f</tt>:
--   
--   <ul>
--   <li>There is an instance of <tt><a>Generic</a> (B f)</tt>.</li>
--   <li><tt>B</tt> has only one constructor (that is, it is not a
--   sum-type).</li>
--   <li>Every field of <tt>B f</tt> is of the form <tt>f a</tt>, for some
--   type <tt>a</tt>. In other words, <tt>B</tt> has no "hidden"
--   structure.</li>
--   </ul>
type CanDeriveProductB b f g = (GenericN (b f), GenericN (b g), GenericN (b (f `Product` g)), GProductB f g (RepN (b f)) (RepN (b g)) (RepN (b (f `Product` g))))

-- | Default implementation of <a>baddDicts</a> based on <a>Generic</a>.
gbaddDictsDefault :: forall b c f. (CanDeriveConstraintsB c b f, AllB c b) => b f -> b (Dict c `Product` f)
class GAllBC repbx => GConstraintsB c (f :: k -> *) repbx repbf repbdf
gbaddDicts :: (GConstraintsB c f repbx repbf repbdf, GAllB c repbx) => repbf x -> repbdf x

-- | <tt><a>CanDeriveConstraintsB</a> B f g</tt> is in practice a predicate
--   about <tt>B</tt> only. Intuitively, it says that the following holds,
--   for any arbitrary <tt>f</tt>:
--   
--   <ul>
--   <li>There is an instance of <tt><a>Generic</a> (B f)</tt>.</li>
--   <li><tt>B f</tt> can contain fields of type <tt>b f</tt> as long as
--   there exists a <tt><a>ConstraintsB</a> b</tt> instance. In particular,
--   recursive usages of <tt>B f</tt> are allowed.</li>
--   </ul>
type CanDeriveConstraintsB c b f = (GenericN (b f), GenericN (b (Dict c `Product` f)), AllB c b ~ GAllB c (GAllBRep b), GConstraintsB c f (GAllBRep b) (RepN (b f)) (RepN (b (Dict c `Product` f))))
class GAllBC (repbf :: * -> *) where {
    type family GAllB (c :: k -> Constraint) repbf :: Constraint;
}

-- | The representation used for the generic computation of the
--   <tt><a>AllB</a> c b</tt> constraints. Here <a>X</a> is an arbitrary
--   constant since the actual argument to <tt>b</tt> is irrelevant.
type GAllBRep b = TagSelf b (RepN (b X))
data X a

-- | We use type-families to generically compute <tt><a>AllB</a> c b</tt>.
--   Intuitively, if <tt>b' f</tt> occurs inside <tt>b f</tt>, then we
--   should just add <tt>AllB b' c</tt> to <tt>AllB b c</tt>. The problem
--   is that if <tt>b</tt> is a recursive type, and <tt>b'</tt> is
--   <tt>b</tt>, then ghc will choke and blow the stack (instead of
--   computing a fixpoint).
--   
--   So, we would like to behave differently when <tt>b = b'</tt> and add
--   <tt>()</tt> instead of `AllB b f` to break the recursion. Our trick
--   will be to use a type family to inspect <tt>RepN (b f)</tt> and
--   distinguish recursive usages from non-recursive ones, tagging them
--   with different types, so we can distinguish them in the instances.
type family TagSelf (b :: (k -> *) -> *) (repbf :: * -> *) :: * -> *
data Self (b :: (k -> *) -> *) (f :: k -> *)
data Other (b :: (k -> *) -> *) (f :: k -> *)

-- | Default implementation of <a>bproof</a> based on <a>Generic</a>.
gbdictsDefault :: forall b c. (CanDeriveProductBC c b, AllB c b) => b (Dict c)
class GProductBC c repbx repbd
gbdicts :: (GProductBC c repbx repbd, GAllB c repbx) => repbd x

-- | Every type that admits a generic instance of <a>ProductB</a> and
--   <a>ConstraintsB</a>, has a generic instance of <a>ProductBC</a> as
--   well.
type CanDeriveProductBC c b = (GenericN (b (Dict c)), AllB c b ~ GAllB c (GAllBRep b), GProductBC c (GAllBRep b) (RepN (b (Dict c))))

-- | Default implementation of <a>bstrip</a> based on <a>Generic</a>.
gbcoverDefault :: CanDeriveBareB b => b Bare Identity -> b Covered Identity

-- | Default implementation of <a>bstrip</a> based on <a>Generic</a>.
gbstripDefault :: CanDeriveBareB b => b Covered Identity -> b Bare Identity
class GBareB repbi repbb
gbstrip :: GBareB repbi repbb => repbi x -> repbb x
gbcover :: GBareB repbi repbb => repbb x -> repbi x

-- | All types that admit a generic FunctorB' instance, and have all their
--   occurrences of <tt>f</tt> under a <a>Wear</a> admit a generic
--   <a>BareB</a> instance.
type CanDeriveBareB b = (GenericN (b Bare Identity), GenericN (b Covered Identity), GBareB (RepN (b Covered Identity)) (RepN (b Bare Identity)))
class (Coercible (Rep a) (RepN a), Generic a) => GenericN (a :: Type)
newtype Rec (p :: Type) a x
Rec :: K1 R a x -> Rec a x
[unRec] :: Rec a x -> K1 R a x
type family RepN (a :: Type) :: Type -> Type


-- | A common Haskell idiom is to parameterise a datatype by a type <tt>k
--   -&gt; *</tt>, typically a functor or a GADT. These are like outfits of
--   a Barbie, that turn her into a different doll. E.g.
--   
--   <pre>
--   data Barbie f
--     = Barbie
--         { name :: f <a>String</a>
--         , age  :: f <a>Int</a>
--         }
--   
--   b1 :: Barbie <a>Last</a>       -- Barbie with a monoid structure
--   b2 :: Barbie (<a>Const</a> a)  -- <a>Container</a> Barbie
--   b3 :: Barbie <a>Identity</a>   -- Barbie's new clothes
--   </pre>
--   
--   This module define the classes to work with these types and easily
--   transform them. They all come with default instances based on
--   <a>Generic</a>, so using them is as easy as:
--   
--   <pre>
--   data Barbie f
--     = Barbie
--         { name :: f <a>String</a>
--         , age  :: f <a>Int</a>
--         }
--     deriving
--       ( <a>Generic</a>
--       , <a>FunctorB</a>, <a>TraversableB</a>, <a>ProductB</a>, <a>ConstraintsB</a>, <a>ProductBC</a>
--       )
--   
--   deriving instance <a>AllBF</a> <a>Show</a> f Barbie =&gt; <a>Show</a> (Barbie f)
--   deriving instance <a>AllBF</a> <a>Eq</a>   f Barbie =&gt; <a>Eq</a>   (Barbie f)
--   </pre>
--   
--   Sometimes one wants to use <tt>Barbie <a>Identity</a></tt> and it may
--   feel like a second-class record type, where one needs to unpack values
--   in each field. <a>Data.Barbie.Bare</a> offers a way to have bare
--   versions of a barbie-type.
--   
--   Notice that all classes in this package are poly-kinded. Intuitively,
--   a barbie is a type parameterised by a functor, and because a barbies
--   is a type of functor, a type parameterised by a barbie is a
--   (higher-kinded) barbie too:
--   
--   <pre>
--   data Catalog b
--     = Catalog (b <tt>Identity</tt>) (b <a>Maybe</a>)
--     deriving
--       (<a>Generic</a>
--       , <a>FunctorB</a>, <a>TraversableB</a>, <a>ProductB</a>, <a>ConstraintsB</a>, <a>ProductBC</a>
--       )
--   </pre>
module Data.Barbie

-- | Barbie-types that can be mapped over. Instances of <a>FunctorB</a>
--   should satisfy the following laws:
--   
--   <pre>
--   <a>bmap</a> <a>id</a> = <a>id</a>
--   <a>bmap</a> f . <a>bmap</a> g = <a>bmap</a> (f . g)
--   </pre>
--   
--   There is a default <a>bmap</a> implementation for <a>Generic</a>
--   types, so instances can derived automatically.
class FunctorB (b :: (k -> Type) -> Type)
bmap :: FunctorB b => (forall a. f a -> g a) -> b f -> b g
bmap :: forall f g. (FunctorB b, CanDeriveFunctorB b f g) => (forall a. f a -> g a) -> b f -> b g

-- | Barbie-types that can be traversed from left to right. Instances
--   should satisfy the following laws:
--   
--   <pre>
--    t . <a>btraverse</a> f   = <a>btraverse</a> (t . f)  -- naturality
--   <a>btraverse</a> <a>Identity</a> = <a>Identity</a>           -- identity
--   <a>btraverse</a> (<a>Compose</a> . <a>fmap</a> g . f) = <a>Compose</a> . <a>fmap</a> (<a>btraverse</a> g) . <a>btraverse</a> f -- composition
--   </pre>
--   
--   There is a default <a>btraverse</a> implementation for <a>Generic</a>
--   types, so instances can derived automatically.
class FunctorB b => TraversableB (b :: (k -> Type) -> Type)
btraverse :: (TraversableB b, Applicative t) => (forall a. f a -> t (g a)) -> b f -> t (b g)
btraverse :: (TraversableB b, Applicative t, CanDeriveTraversableB b f g) => (forall a. f a -> t (g a)) -> b f -> t (b g)

-- | Map each element to an action, evaluate these actions from left to
--   right, and ignore the results.
btraverse_ :: (TraversableB b, Applicative t) => (forall a. f a -> t c) -> b f -> t ()

-- | Map each element to a monoid, and combine the results.
bfoldMap :: (TraversableB b, Monoid m) => (forall a. f a -> m) -> b f -> m

-- | Evaluate each action in the structure from left to right, and collect
--   the results.
bsequence :: (Applicative f, TraversableB b) => b (Compose f g) -> f (b g)

-- | A version of <a>bsequence</a> with <tt>g</tt> specialized to
--   <a>Identity</a>.
bsequence' :: (Applicative f, TraversableB b) => b f -> f (b Identity)

-- | Barbie-types that can form products, subject to the laws:
--   
--   <pre>
--   <a>bmap</a> (\(<a>Pair</a> a _) -&gt; a) . <a>uncurry</a> <a>bprod</a> = <a>fst</a>
--   <a>bmap</a> (\(<a>Pair</a> _ b) -&gt; b) . <a>uncurry</a> <a>bprod</a> = <a>snd</a>
--   </pre>
--   
--   Notice that because of the laws, having an internal product structure
--   is not enough to have a lawful instance. E.g.
--   
--   <pre>
--   data Ok  f = Ok {o1 :: f <a>String</a>, o2 :: f <a>Int</a>}
--   data Bad f = Bad{b1 :: f <a>String</a>, hiddenFromArg: <a>Int</a>} -- no lawful instance
--   </pre>
--   
--   Intuitively, the laws for this class require that <tt>b</tt> hides no
--   structure from its argument <tt>f</tt>. Because of this, if we are
--   given any:
--   
--   <pre>
--   x :: forall a . f a
--   </pre>
--   
--   then this determines a unique value of type <tt>b f</tt>, witnessed by
--   the <a>buniq</a> method. For example:
--   
--   <pre>
--   <a>buniq</a> x = Ok {o1 = x, o2 = x}
--   </pre>
--   
--   Formally, <a>buniq</a> should satisfy:
--   
--   <pre>
--   <a>const</a> (<a>buniq</a> x) = <a>bmap</a> (<a>const</a> x)
--   </pre>
--   
--   There is a default implementation of <a>bprod</a> and <a>buniq</a> for
--   <a>Generic</a> types, so instances can derived automatically.
class FunctorB b => ProductB (b :: (k -> Type) -> Type)
bprod :: ProductB b => b f -> b g -> b (f `Product` g)
buniq :: ProductB b => (forall a. f a) -> b f
bprod :: (ProductB b, CanDeriveProductB b f g) => b f -> b g -> b (f `Product` g)
buniq :: (ProductB b, CanDeriveProductB b f f) => (forall a. f a) -> b f

-- | An alias of <a>bprod</a>, since this is like a <a>zip</a> for
--   Barbie-types.
bzip :: ProductB b => b f -> b g -> b (f `Product` g)

-- | An equivalent of <a>unzip</a> for Barbie-types.
bunzip :: ProductB b => b (f `Product` g) -> (b f, b g)

-- | An equivalent of <a>zipWith</a> for Barbie-types.
bzipWith :: ProductB b => (forall a. f a -> g a -> h a) -> b f -> b g -> b h

-- | An equivalent of <a>zipWith3</a> for Barbie-types.
bzipWith3 :: ProductB b => (forall a. f a -> g a -> h a -> i a) -> b f -> b g -> b h -> b i

-- | An equivalent of <a>zipWith4</a> for Barbie-types.
bzipWith4 :: ProductB b => (forall a. f a -> g a -> h a -> i a -> j a) -> b f -> b g -> b h -> b i -> b j

-- | Like <a>bprod</a>, but returns a binary <a>Prod</a>, instead of
--   <a>Product</a>, which composes better.
--   
--   See <a>/*/</a> for usage.
(/*/) :: ProductB b => b f -> b g -> b (Prod '[f, g])
infixr 4 /*/

-- | Similar to <a>/*/</a> but one of the sides is already a
--   <tt><a>Prod</a> fs</tt>.
--   
--   Note that <a>/*</a>, <a>/*/</a> and <a>uncurryn</a> are meant to be
--   used together: <a>/*</a> and <a>/*/</a> combine <tt>b f1, b f2...b
--   fn</tt> into a single product that can then be consumed by using
--   <a>uncurryn</a> on an n-ary function. E.g.
--   
--   <pre>
--   f :: f a -&gt; g a -&gt; h a -&gt; i a
--   
--   <a>bmap</a> (<a>uncurryn</a> f) (bf <a>/*</a> bg <a>/*/</a> bh)
--   </pre>
(/*) :: ProductB b => b f -> b (Prod fs) -> b (Prod (f : fs))
infixr 4 /*

-- | Instances of this class provide means to talk about constraints, both
--   at compile-time, using <a>AllB</a>, and at run-time, in the form of
--   <a>Dict</a>, via <a>baddDicts</a>.
--   
--   A manual definition would look like this:
--   
--   <pre>
--   data T f = A (f <a>Int</a>) (f <a>String</a>) | B (f <a>Bool</a>) (f <a>Int</a>)
--   
--   instance <a>ConstraintsB</a> T where
--     type <a>AllB</a> c T = (c <a>Int</a>, c <a>String</a>, c <a>Bool</a>)
--   
--     <a>baddDicts</a> t = case t of
--       A x y -&gt; A (<a>Pair</a> <a>Dict</a> x) (<a>Pair</a> <a>Dict</a> y)
--       B z w -&gt; B (<a>Pair</a> <a>Dict</a> z) (<a>Pair</a> <a>Dict</a> w)
--   </pre>
--   
--   Now if we given a <tt>T f</tt>, we need to use the <a>Show</a>
--   instance of their fields, we can use:
--   
--   <pre>
--   <a>baddDicts</a> :: AllB Show b =&gt; b f -&gt; b (<a>Dict</a> <a>Show</a> <a>Product</a> b)
--   </pre>
--   
--   There is a default implementation of <a>ConstraintsB</a> for
--   <a>Generic</a> types, so in practice one will simply do:
--   
--   <pre>
--   derive instance <a>Generic</a> (T f)
--   instance <a>ConstraintsB</a> T
--   </pre>
class FunctorB b => ConstraintsB (b :: (k -> *) -> *) where {
    
    -- | <tt><a>AllB</a> c b</tt> should contain a constraint <tt>c a</tt> for
    --   each <tt>a</tt> occurring under an <tt>f</tt> in <tt>b f</tt>. E.g.:
    --   
    --   <pre>
    --   <a>AllB</a> <a>Show</a> Barbie ~ (<a>Show</a> <a>String</a>, <a>Show</a> <a>Int</a>)
    --   </pre>
    --   
    --   For requiring constraints of the form <tt>c (f a)</tt>, use
    --   <a>AllBF</a>.
    type family AllB (c :: k -> Constraint) b :: Constraint;
    type AllB c b = GAllB c (GAllBRep b);
}
baddDicts :: forall c f. (ConstraintsB b, AllB c b) => b f -> b (Dict c `Product` f)
baddDicts :: forall c f. (ConstraintsB b, CanDeriveConstraintsB c b f, AllB c b) => b f -> b (Dict c `Product` f)

-- | Similar to <a>AllB</a> but will put the functor argument <tt>f</tt>
--   between the constraint <tt>c</tt> and the type <tt>a</tt>. For
--   example:
--   
--   <pre>
--   <a>AllB</a>  <a>Show</a>   Barbie ~ (<a>Show</a>    <a>String</a>,  <a>Show</a>    <a>Int</a>)
--   <a>AllBF</a> <a>Show</a> f Barbie ~ (<a>Show</a> (f <a>String</a>), <a>Show</a> (f <a>Int</a>))
--   
--   </pre>
type AllBF c f b = AllB (ClassF c f) b

-- | Like <a>bmap</a> but a constraint is allowed to be required on each
--   element of <tt>b</tt>
--   
--   E.g. If all fields of <tt>b</tt> are <a>Show</a>able then you could
--   store each shown value in it's slot using <a>Const</a>:
--   
--   <pre>
--   showFields :: (AllB Show b, ConstraintsB b) =&gt; b Identity -&gt; b (Const String)
--   showFields = bmapC @Show showField
--     where
--       showField :: forall a. Show a =&gt; Identity a -&gt; Const String a
--       showField (Identity a) = Const (show a)
--   </pre>
bmapC :: forall c b f g. (AllB c b, ConstraintsB b) => (forall a. c a => f a -> g a) -> b f -> b g

-- | Like <a>btraverse</a> but with a constraint on the elements of
--   <tt>b</tt>.
btraverseC :: forall c b f g h. (TraversableB b, ConstraintsB b, AllB c b, Applicative g) => (forall a. c a => f a -> g (h a)) -> b f -> g (b h)

-- | Every type <tt>b</tt> that is an instance of both <a>ProductB</a> and
--   <a>ConstraintsB</a> can be made an instance of <a>ProductBC</a> as
--   well.
--   
--   Intuitively, in addition to <a>buniq</a> from <a>ProductB</a>, one can
--   define <a>buniqC</a> that takes into account constraints:
--   
--   <pre>
--   <a>buniq</a> :: (forall a . f a) -&gt; b f
--   <a>buniqC</a> :: <a>AllB</a> c b =&gt; (forall a . c a =&gt; f a) -&gt; b f
--   </pre>
--   
--   For technical reasons, <a>buniqC</a> is not currently provided as a
--   method of this class and is instead defined in terms <a>bdicts</a>,
--   which is similar to <a>baddDicts</a> but can produce the instance
--   dictionaries out-of-the-blue. <a>bdicts</a> could also be defined in
--   terms of <a>buniqC</a>, so they are essentially equivalent.
--   
--   <pre>
--   <a>bdicts</a> :: forall c b . <a>AllB</a> c b =&gt; b (<a>Dict</a> c)
--   <a>bdicts</a> = <a>buniqC</a> (<a>Dict</a> @c)
--   </pre>
--   
--   There is a default implementation for <a>Generic</a> types, so
--   instances can derived automatically.
class (ConstraintsB b, ProductB b) => ProductBC (b :: (k -> Type) -> Type)
bdicts :: (ProductBC b, AllB c b) => b (Dict c)
bdicts :: (ProductBC b, CanDeriveProductBC c b, AllB c b) => b (Dict c)

-- | Like <a>buniq</a> but a constraint is allowed to be required on each
--   element of <tt>b</tt>.
buniqC :: forall c f b. (AllB c b, ProductBC b) => (forall a. c a => f a) -> b f

-- | Builds a <tt>b f</tt>, by applying <a>mempty</a> on every field of
--   <tt>b</tt>.
bmempty :: forall f b. (AllBF Monoid f b, ProductBC b) => b f

-- | A wrapper for Barbie-types, providing useful instances.
newtype Barbie (b :: (k -> Type) -> Type) f
Barbie :: b f -> Barbie f
[getBarbie] :: Barbie f -> b f

-- | Uninhabited barbie type.
data Void (f :: k -> Type)

-- | A barbie type without structure.
data Unit (f :: k -> Type)
Unit :: Unit
newtype Rec (p :: Type) a x
Rec :: K1 R a x -> Rec a x
[unRec] :: Rec a x -> K1 R a x

-- | <i>Deprecated: Renamed to AllBF (now based on AllB)</i>
type ConstraintsOf c f b = AllBF c f b

-- | <i>Deprecated: Renamed to baddDicts</i>
adjProof :: forall b c f. (ConstraintsB b, AllB c b) => b f -> b (Dict c `Product` f)

-- | <i>Deprecated: Class was renamed to ProductBC</i>
type ProofB b = ProductBC b

-- | <i>Deprecated: Renamed to bdicts</i>
bproof :: forall b c. (ProductBC b, AllB c b) => b (Dict c)


-- | We get a container of <tt>a</tt>'s for any Barbie-type when we make it
--   wear a <tt>(<a>Const</a> a)</tt> . The <a>Container</a> wrapper gives
--   us the expected instances for a container type.
module Data.Barbie.Container

-- | Wrapper for container-Barbies.
newtype Container b a
Container :: b (Const a) -> Container b a
[getContainer] :: Container b a -> b (Const a)
instance GHC.Generics.Generic (Data.Barbie.Container.Container b a)
instance GHC.Classes.Eq (b (Data.Functor.Const.Const a)) => GHC.Classes.Eq (Data.Barbie.Container.Container b a)
instance GHC.Classes.Ord (b (Data.Functor.Const.Const a)) => GHC.Classes.Ord (Data.Barbie.Container.Container b a)
instance GHC.Read.Read (b (Data.Functor.Const.Const a)) => GHC.Read.Read (Data.Barbie.Container.Container b a)
instance GHC.Show.Show (b (Data.Functor.Const.Const a)) => GHC.Show.Show (Data.Barbie.Container.Container b a)
instance Data.Barbie.Internal.Functor.FunctorB b => GHC.Base.Functor (Data.Barbie.Container.Container b)
instance Data.Barbie.Internal.Traversable.TraversableB b => Data.Foldable.Foldable (Data.Barbie.Container.Container b)
instance Data.Barbie.Internal.Traversable.TraversableB b => Data.Traversable.Traversable (Data.Barbie.Container.Container b)
instance Data.Barbie.Internal.Product.ProductB b => GHC.Base.Applicative (Data.Barbie.Container.Container b)
