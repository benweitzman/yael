-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | OpenTracing for Haskell
--   
--   OpenTracing for Haskell
@package opentracing
@version 0.1.0.0


-- | Logs are structured data that occur over the lifetime of a span.
module OpenTracing.Log

-- | A single entry into a <tt>Spans</tt> logs. Occurs at a single time and
--   contains multiple (one or more) entries.
data LogRecord
LogRecord :: UTCTime -> NonEmpty LogField -> LogRecord
[_logTime] :: LogRecord -> UTCTime
[_logFields] :: LogRecord -> NonEmpty LogField
logTime :: Lens' LogRecord UTCTime
logFields :: Lens' LogRecord (NonEmpty LogField)

-- | A piece of data in a <a>LogRecord</a>. Conceptually a key:value pair
--   with a few distinguished keys. More info about the distinguished keys
--   in the <a>OpenTracing spec</a>
data LogField

-- | A generic key:value pair entry into a <a>LogRecord</a>
[LogField] :: Show a => Text -> a -> LogField

-- | A stable identifier for some notable moment in the lifetime of a Span.
[Event] :: Text -> LogField

-- | A concise, human-readable, one-line message explaining the event.
[Message] :: Text -> LogField

-- | A stack trace in platform-conventional format
[Stack] :: CallStack -> LogField

-- | The type or "kind" of an error (only for event="error" logs).
[ErrKind] :: Text -> LogField

-- | The actual error exception
[ErrObj] :: Exception e => e -> LogField

-- | Retrieve the label of a log field. Distinguished <a>LogField</a>s have
--   predefined keys.
logFieldLabel :: LogField -> Text
logFieldEncoding :: LogField -> Encoding
logFieldValue :: LogField -> Value
type LogFieldsFormatter = forall t. Foldable t => t LogField -> Builder

-- | A log formatter that encodes each <a>LogField</a> as a single JSON
--   object.
--   
--   <pre>
--   &gt;&gt;&gt; BS.hPutBuilder stdout $ jsonAssoc [Event "e", LogField @Text "key" "value"]
--   [{"event":"\"e\""},{"key":"\"value\""}]
--   </pre>
jsonAssoc :: LogFieldsFormatter

-- | A log formatter that encodes each <a>LogField</a> as an entry in a
--   shared JSON object
--   
--   <pre>
--   &gt;&gt;&gt; BS.hPutBuilder stdout $ jsonMap  [Event "e", LogField @Text "key" "value"]
--   {"event":"e","key":"\"value\""}
--   </pre>
jsonMap :: LogFieldsFormatter
instance GHC.Show.Show OpenTracing.Log.LogRecord
instance GHC.Show.Show OpenTracing.Log.LogField

module OpenTracing.Time
class AsMicros a
micros :: (AsMicros a, Integral b) => a -> b
instance OpenTracing.Time.AsMicros Data.Time.Clock.Internal.UTCTime.UTCTime
instance OpenTracing.Time.AsMicros Data.Time.Clock.Internal.NominalDiffTime.NominalDiffTime

module OpenTracing.Types
data TraceID
TraceID :: Maybe Word64 -> Word64 -> TraceID
[traceIdHi] :: TraceID -> Maybe Word64
[traceIdLo] :: TraceID -> Word64
newtype IPv4
IPv4 :: IPv4 -> IPv4
[fromIPv4] :: IPv4 -> IPv4
newtype IPv6
IPv6 :: IPv6 -> IPv6
[fromIPv6] :: IPv6 -> IPv6
newtype Port
Port :: Word16 -> Port
[fromPort] :: Port -> Word16
data Protocol
UDP :: Protocol
HTTP :: Protocol
data Addr a
[UDPAddr] :: HostName -> Port -> Addr  'UDP
[HTTPAddr] :: HostName -> Port -> Bool -> Addr  'HTTP
addrHostName :: Lens' (Addr a) HostName
addrPort :: Lens' (Addr a) Port
addrSecure :: Lens' (Addr  'HTTP) Bool
data Hex
knownHex :: Text -> Hex
class AsHex a
_Hex :: AsHex a => Prism' Hex a
hexText :: AsHex a => Getter a Text
instance GHC.Base.Semigroup OpenTracing.Types.Hex
instance GHC.Base.Monoid OpenTracing.Types.Hex
instance GHC.Show.Show OpenTracing.Types.Hex
instance GHC.Classes.Eq OpenTracing.Types.Hex
instance GHC.Classes.Ord OpenTracing.Types.Port
instance GHC.Num.Num OpenTracing.Types.Port
instance GHC.Classes.Eq OpenTracing.Types.Port
instance GHC.Enum.Enum OpenTracing.Types.Port
instance GHC.Classes.Ord OpenTracing.Types.IPv6
instance GHC.Classes.Eq OpenTracing.Types.IPv6
instance GHC.Enum.Enum OpenTracing.Types.IPv6
instance GHC.Enum.Bounded OpenTracing.Types.IPv6
instance GHC.Classes.Ord OpenTracing.Types.IPv4
instance GHC.Classes.Eq OpenTracing.Types.IPv4
instance GHC.Enum.Enum OpenTracing.Types.IPv4
instance GHC.Enum.Bounded OpenTracing.Types.IPv4
instance GHC.Show.Show OpenTracing.Types.TraceID
instance GHC.Classes.Ord OpenTracing.Types.TraceID
instance GHC.Classes.Eq OpenTracing.Types.TraceID
instance OpenTracing.Types.AsHex OpenTracing.Types.TraceID
instance OpenTracing.Types.AsHex GHC.Word.Word64
instance GHC.Show.Show OpenTracing.Types.Port
instance GHC.Read.Read OpenTracing.Types.Port
instance Data.Aeson.Types.ToJSON.ToJSON OpenTracing.Types.Port
instance GHC.Show.Show OpenTracing.Types.IPv6
instance GHC.Read.Read OpenTracing.Types.IPv6
instance Data.Aeson.Types.ToJSON.ToJSON OpenTracing.Types.IPv6
instance GHC.Show.Show OpenTracing.Types.IPv4
instance GHC.Read.Read OpenTracing.Types.IPv4
instance Data.Aeson.Types.ToJSON.ToJSON OpenTracing.Types.IPv4

module OpenTracing.Tags

-- | Tags are structured data associated with a <a>Span</a>. They can give
--   a more complete picture of what a Span is doing than the operation
--   alone. Tags apply to the entire timerange of a Span. Use
--   <a>LogField</a> for events that refer to particular timestamp.
data Tags

-- | A Tag is a key:value pair
type Tag = (Text, TagVal)
data TagVal
BoolT :: Bool -> TagVal
StringT :: Text -> TagVal
IntT :: Int64 -> TagVal
DoubleT :: Double -> TagVal
BinaryT :: ByteString -> TagVal
setTag :: Tag -> Tags -> Tags
getTag :: Text -> Tags -> Maybe TagVal

-- | Get a tag and attempt to convert it from a serialized format
getTagReify :: Getting (First b) Tag b -> Text -> Tags -> Maybe b
pattern ComponentKey :: forall a. (Eq a, IsString a) => () => a
pattern DbInstanceKey :: forall a. (Eq a, IsString a) => () => a
pattern DbStatementKey :: forall a. (Eq a, IsString a) => () => a
pattern DbTypeKey :: forall a. (Eq a, IsString a) => () => a
pattern DbUserKey :: forall a. (Eq a, IsString a) => () => a
pattern ErrorKey :: forall a. (Eq a, IsString a) => () => a
pattern HttpMethodKey :: forall a. (Eq a, IsString a) => () => a
pattern HttpStatusCodeKey :: forall a. (Eq a, IsString a) => () => a
pattern HttpUrlKey :: forall a. (Eq a, IsString a) => () => a
pattern MessageBusDestinationKey :: forall a. (Eq a, IsString a) => () => a
pattern PeerAddressKey :: forall a. (Eq a, IsString a) => () => a
pattern PeerHostnameKey :: forall a. (Eq a, IsString a) => () => a
pattern PeerIPv4Key :: forall a. (Eq a, IsString a) => () => a
pattern PeerIPv6Key :: forall a. (Eq a, IsString a) => () => a
pattern PeerPortKey :: forall a. (Eq a, IsString a) => () => a
pattern PeerServiceKey :: forall a. (Eq a, IsString a) => () => a
pattern SamplingPriorityKey :: forall a. (Eq a, IsString a) => () => a
pattern SpanKindKey :: forall a. (Eq a, IsString a) => () => a
pattern Component :: () => () => Text -> Tag
pattern DbInstance :: () => () => Text -> Tag
pattern DbStatement :: () => () => Text -> Tag
pattern DbType :: () => () => Text -> Tag
pattern DbUser :: () => () => Text -> Tag
pattern Error :: () => () => Bool -> Tag
pattern HttpMethod :: () => () => Method -> Tag
pattern HttpStatusCode :: () => () => Status -> Tag
pattern HttpUrl :: () => () => Text -> Tag
pattern MessageBusDestination :: () => () => Text -> Tag
pattern PeerAddress :: () => () => Text -> Tag
pattern PeerHostname :: () => () => Text -> Tag
pattern PeerIPv4 :: () => () => IPv4 -> Tag
pattern PeerIPv6 :: () => () => IPv6 -> Tag
pattern PeerPort :: () => () => Port -> Tag
pattern PeerService :: () => () => Text -> Tag
pattern SamplingPriority :: () => () => Word8 -> Tag
pattern SpanKind :: () => () => SpanKinds -> Tag
_Component :: Prism' Tag Text
_DbInstance :: Prism' Tag Text
_DbStatement :: Prism' Tag Text
_DbType :: Prism' Tag Text
_DbUser :: Prism' Tag Text
_Error :: Prism' Tag Bool
_HttpMethod :: Prism' Tag Method
_HttpStatusCode :: Prism' Tag Status
_HttpUrl :: Prism' Tag Text
_MessageBusDestination :: Prism' Tag Text
_PeerAddress :: Prism' Tag Text
_PeerHostname :: Prism' Tag Text
_PeerIPv4 :: Prism' Tag IPv4
_PeerIPv6 :: Prism' Tag IPv6
_PeerPort :: Prism' Tag Port
_PeerService :: Prism' Tag Text
_SamplingPriority :: Prism' Tag Word8
_SpanKind :: Prism' Tag SpanKinds
data SpanKinds
RPCClient :: SpanKinds
RPCServer :: SpanKinds
Producer :: SpanKinds
Consumer :: SpanKinds
spanKindLabel :: SpanKinds -> Text
instance GHC.Classes.Ord OpenTracing.Tags.SpanKinds
instance GHC.Show.Show OpenTracing.Tags.SpanKinds
instance GHC.Classes.Eq OpenTracing.Tags.SpanKinds
instance Data.Aeson.Types.ToJSON.ToJSON OpenTracing.Tags.Tags
instance GHC.Base.Monoid OpenTracing.Tags.Tags
instance GHC.Base.Semigroup OpenTracing.Tags.Tags
instance GHC.Show.Show OpenTracing.Tags.Tags
instance GHC.Classes.Eq OpenTracing.Tags.Tags
instance GHC.Show.Show OpenTracing.Tags.TagVal
instance GHC.Classes.Eq OpenTracing.Tags.TagVal
instance Data.Aeson.Types.ToJSON.ToJSON OpenTracing.Tags.SpanKinds
instance Data.Aeson.Types.ToJSON.ToJSON OpenTracing.Tags.TagVal


-- | Data types and functions for manipulating <a>spans</a>
module OpenTracing.Span

-- | A <a>SpanContext</a> is the data that uniquely identifies a span and
--   the context in which it occurs. Spans occur in traces, which form
--   complete pictures of a computation, potentially across multiple
--   machines.
data SpanContext
SpanContext :: TraceID -> Word64 -> Maybe Word64 -> Sampled -> HashMap Text Text -> SpanContext

-- | A trace identifier. Trace ids are globally unique
[ctxTraceID] :: SpanContext -> TraceID

-- | A span identifier. Span identifiers are unique to their trace.
[ctxSpanID] :: SpanContext -> Word64

-- | Spans without a parent are known as "root spans"
[ctxParentSpanID] :: SpanContext -> Maybe Word64

-- | Whether or not this span is going to be reported.
[_ctxSampled] :: SpanContext -> Sampled

-- | Baggage is arbitrary key:value pairs that cross process boundaries.
[_ctxBaggage] :: SpanContext -> HashMap Text Text
ctxSampled :: Lens' SpanContext Sampled
ctxBaggage :: Lens' SpanContext (HashMap Text Text)

-- | <a>Span</a> is a span that has been started (but not finished). See
--   the <a>OpenTracing spec</a> for more info
data Span

-- | Create a new <a>Span</a> with the provided info. The created
--   <a>Span</a> will have a start time equal to the system time when
--   <a>newSpan</a> is called.
newSpan :: (MonadIO m, Foldable t) => SpanContext -> Text -> SpanRefs -> t Tag -> m Span
class HasSpanFields a

-- | A mutable <a>Span</a> that is currently being recorded.
data ActiveSpan

mkActive :: Span -> IO ActiveSpan

modifyActiveSpan :: ActiveSpan -> (Span -> Span) -> IO ()

readActiveSpan :: ActiveSpan -> IO Span

-- | Log structured data to an <a>ActiveSpan</a>. More info in the
--   <a>OpenTracing spec</a>
addLogRecord :: ActiveSpan -> LogField -> IO ()
addLogRecord' :: ActiveSpan -> LogField -> [LogField] -> IO ()
setBaggageItem :: ActiveSpan -> Text -> Text -> IO ()
getBaggageItem :: ActiveSpan -> Text -> IO (Maybe Text)

-- | A span that has finished executing.
data FinishedSpan

-- | Convert an unfinished <a>Span</a> into a <a>FinishedSpan</a>
spanFinish :: MonadIO m => Span -> m FinishedSpan
spanContext :: HasSpanFields a => Lens' a SpanContext
spanOperation :: HasSpanFields a => Lens' a Text
spanStart :: HasSpanFields a => Lens' a UTCTime
spanTags :: HasSpanFields a => Lens' a Tags
spanRefs :: HasRefs s a => Lens' s a
spanLogs :: HasSpanFields a => Lens' a [LogRecord]
spanDuration :: Lens' FinishedSpan NominalDiffTime

-- | <a>SpanOpts</a> is the metadata information about a span needed in
--   order to start measuring a span. This is the information that
--   application code will provide in order to indicate what a span is
--   doing and how it related to other spans. More info in the
--   <a>OpenTracing spec</a>
data SpanOpts

-- | Create a new <a>SpanOpts</a> with the minimal amount of required
--   information.
spanOpts :: Text -> SpanRefs -> SpanOpts
spanOptOperation :: Lens' SpanOpts Text
spanOptRefs :: Lens' SpanOpts SpanRefs
spanOptTags :: Lens' SpanOpts [Tag]
spanOptSampled :: Lens' SpanOpts (Maybe Sampled)

-- | A reference from one span to another. Spans can be related in two
--   ways:
--   
--   <ul>
--   <li><a>ChildOf</a> indicates that the parent span is dependent on the
--   child span in order to produce its own result.</li>
--   <li><a>FollowsFrom</a> indicates that there is no dependence relation,
--   perhaps the parent span spawned an asynchronous task.</li>
--   </ul>
--   
--   More info in the <a>OpenTracing spec</a>
data Reference
ChildOf :: SpanContext -> Reference
[refCtx] :: Reference -> SpanContext
FollowsFrom :: SpanContext -> Reference
[refCtx] :: Reference -> SpanContext
findParent :: Foldable t => t Reference -> Maybe Reference

-- | The different references that a span can hold to other spans.
data SpanRefs
refActiveParents :: Lens' SpanRefs [ActiveSpan]
refPredecessors :: Lens' SpanRefs [FinishedSpan]
refPropagated :: Lens' SpanRefs [Reference]

-- | Create a <a>SpanRefs</a> containing the single refrence to a parent
--   span.
childOf :: ActiveSpan -> SpanRefs

-- | Create a <a>SpanRefs</a> containing the single refrence to a
--   predecessor span.
followsFrom :: FinishedSpan -> SpanRefs

-- | Convert <a>SpanRefs</a> (which may include the mutable
--   <a>ActiveSpan</a>s) into an immutable list of <a>Reference</a>s
freezeRefs :: SpanRefs -> IO [Reference]

-- | A datatype indicating whether a recorded span was sampled, i.e.
--   whether or not it will be reported. Traces are often sampled in high
--   volume environments to keep the amount of data generated manageable.
data Sampled
NotSampled :: Sampled
Sampled :: Sampled
_IsSampled :: Iso' Bool Sampled
sampled :: HasSampled a => Lens' a Sampled

-- | A wrapper for a value that was produced by a traced computation.
data Traced a
Traced :: a -> ~FinishedSpan -> Traced a

-- | The raw value produced
[tracedResult] :: Traced a -> a

-- | The resulting span that was created
[tracedSpan] :: Traced a -> ~FinishedSpan
instance OpenTracing.Span.HasRefs OpenTracing.Span.Span OpenTracing.Span.SpanRefs
instance OpenTracing.Span.HasRefs OpenTracing.Span.FinishedSpan [OpenTracing.Span.Reference]
instance OpenTracing.Span.HasSampled OpenTracing.Span.Sampled
instance OpenTracing.Span.HasSampled OpenTracing.Span.SpanContext
instance OpenTracing.Span.HasSampled OpenTracing.Span.Span
instance OpenTracing.Span.HasSampled OpenTracing.Span.FinishedSpan
instance OpenTracing.Span.HasSpanFields OpenTracing.Span.Span
instance OpenTracing.Span.HasSpanFields OpenTracing.Span.FinishedSpan
instance GHC.Enum.Enum OpenTracing.Span.Sampled
instance GHC.Enum.Bounded OpenTracing.Span.Sampled
instance GHC.Read.Read OpenTracing.Span.Sampled
instance GHC.Show.Show OpenTracing.Span.Sampled
instance GHC.Classes.Eq OpenTracing.Span.Sampled
instance GHC.Base.Semigroup OpenTracing.Span.SpanRefs
instance GHC.Base.Monoid OpenTracing.Span.SpanRefs
instance Data.Aeson.Types.ToJSON.ToJSON OpenTracing.Span.SpanContext
instance Data.Aeson.Types.ToJSON.ToJSON OpenTracing.Span.Sampled


-- | This module provides mid and high level tracing functions.
module OpenTracing.Tracer

-- | A <a>Tracer</a> is a set of effectful actions that define the
--   mid-level interface to an <a>OpenTracing tracer</a>
--   
--   Appliction code should generally construct a <a>Tracer</a> once and
--   then use other higher-level functions such as <a>traced</a>,
--   <a>startSpan</a>, <tt>finishedSpan</tt>.
data Tracer
Tracer :: (forall m. MonadIO m => SpanOpts -> m Span) -> (forall m. MonadIO m => FinishedSpan -> m ()) -> Tracer

-- | Start recording a new span with the given options. This is a mid-level
--   operation that will handle start timing and random span ID generation.
--   
--   Application code should supply this field with <tt>stdTracer</tt>.
[tracerStart] :: Tracer -> forall m. MonadIO m => SpanOpts -> m Span

-- | Report a finished span. What reporting means for each application will
--   depend on where this data is going. There are multiple backends that
--   define reporters for Google Cloudtrace, Zipkin, and Jaeger, for
--   example.
[tracerReport] :: Tracer -> forall m. MonadIO m => FinishedSpan -> m ()

-- | Typeclass for application environments that contain a <a>Tracer</a>.
class HasTracer a
tracer :: HasTracer a => Getting r a Tracer
runTracer :: HasTracer r => r -> ReaderT r m a -> m a

-- | Trace a computation as a span. This is a high-level operation that
--   will handle all aspects of the trace, including timing and reporting.
--   If the traced computation throws an excpetion, <a>traced</a> will
--   clean up and add logs before rethrowing the exception
--   
--   <pre>
--   traced tracer (spanOpts "hello" mempty          ) $ parent -&gt;
--   traced tracer (spanOpts "world" (childOf parent)) $ child -&gt;
--      liftIO $ do
--          putStrLn "doing some work..."
--          addLogRecord child (Message "doing some work")
--          threadDelay 500000
--   </pre>
traced :: (HasTracer t, MonadMask m, MonadIO m) => t -> SpanOpts -> (ActiveSpan -> m a) -> m (Traced a)

-- | Variant of <a>traced</a> that doesn't return the wrapped value.
traced_ :: (HasTracer t, MonadMask m, MonadIO m) => t -> SpanOpts -> (ActiveSpan -> m a) -> m a

-- | Start recording a span
startSpan :: (HasTracer t, MonadIO m) => t -> SpanOpts -> m ActiveSpan

-- | Finish recording a span
finishSpan :: (HasTracer t, MonadIO m) => t -> ActiveSpan -> m FinishedSpan
instance OpenTracing.Tracer.HasTracer OpenTracing.Tracer.Tracer


-- | Logging reporters that emit spans to stdout, stderr and System.IO
--   <tt>Handles</tt>.
module OpenTracing.Reporting.Stdio

-- | Implementation of <a>tracerReport</a> that logs <a>FinishedSpan</a>s
--   to stdout
stdoutReporter :: MonadIO m => FinishedSpan -> m ()

-- | Implementation of <a>tracerReport</a> that logs <a>FinishedSpan</a>s
--   to stderr
stderrReporter :: MonadIO m => FinishedSpan -> m ()

-- | Implementation of <a>tracerReport</a> that logs <a>FinishedSpan</a>s
--   to a <a>Handle</a>.
stdioReporter :: MonadIO m => Handle -> FinishedSpan -> m ()


-- | Reporters with no external components.
module OpenTracing.Reporting.Pure

-- | A null reporter which ignores anything it's given.
noReporter :: MonadIO m => FinishedSpan -> m ()

-- | A reporter which stores the finished spans in memory where they wait
--   to be consumed.
memReporter :: MonadIO m => Mem -> FinishedSpan -> m ()

-- | Construct a new <a>memReporter</a> environment that can store an
--   unbounded seequence of <a>FinishedSpan</a>s.
newMem :: IO Mem

-- | Construct a new <a>memReporter</a> environment that stores a bounded
--   sequence of <a>FinishedSpan</a>s
newBoundedMem :: Word32 -> IO Mem

-- | View the <tt>FinishedSpans</tt> in a <a>memReporter</a> without
--   removing them.
memPeek :: Mem -> IO [FinishedSpan]

-- | View and remove the <tt>FinishedSpans</tt> in a <a>memReporter</a>.
memTake :: Mem -> IO [FinishedSpan]


-- | This module provides a trace reporter that groups recorded spans into
--   batches before sending them to their destination in bulk.
module OpenTracing.Reporting.Batch

-- | Options available to construct a batch reporter. Default options are
--   available with <a>batchOptions</a>
data BatchOptions

-- | Default batch options which can be overridden via lenses.
batchOptions :: ([FinishedSpan] -> IO ()) -> BatchOptions
boptBatchSize :: Lens' BatchOptions Word16
boptTimeoutSec :: Lens' BatchOptions Word
boptReporter :: Lens' BatchOptions ([FinishedSpan] -> IO ())
boptErrorLog :: Lens' BatchOptions (Builder -> IO ())

-- | An error logging function which prints to stderr.
defaultErrorLog :: Builder -> IO ()

-- | The environment of a batch reporter.
data BatchEnv

-- | Create a new batch environment
newBatchEnv :: BatchOptions -> IO BatchEnv

-- | Close a batch reporter, stop consuming any new spans. Any spans in the
--   queue will be drained.
closeBatchEnv :: BatchEnv -> IO ()

-- | An implementation of <a>tracerReport</a> that batches the finished
--   spans for transimission to their destination.
batchReporter :: MonadIO m => BatchEnv -> FinishedSpan -> m ()

module OpenTracing.Reporting


-- | Distributed traces are sampled, meaning they (and the spans that make
--   them up) are selected to either be reported or not.
--   
--   This module defines a few different ways to determine if a given trace
--   should be sampled.
module OpenTracing.Sampling

-- | A <a>Sampler</a> is an algorithm for determine if a trace should be
--   reported.
newtype Sampler
Sampler :: (forall m. MonadIO m => TraceID -> Text -> m Bool) -> Sampler

-- | Run a sampler, providing it a trace id and the operation of the span.
[runSampler] :: Sampler -> forall m. MonadIO m => TraceID -> Text -> m Bool

-- | A <a>Sampler</a> that always returns the given value. Useful for debug
--   environments.
constSampler :: Bool -> Sampler

-- | A <a>Sampler</a> that randomly chooses to report a given percentage of
--   traces. The source of randomness is the ID of the trace.
probSampler :: Double -> Sampler

-- | A <a>Sampler</a> that will report the given number of traces per
--   second.
rateLimitSampler :: Double -> IO Sampler


-- | Standard implementations of <a>Tracer</a> fields.
module OpenTracing.Standard

-- | A standard environment for generating trace and span IDs.
data StdEnv
newStdEnv :: MonadIO m => Sampler -> m StdEnv
envTraceID128bit :: Lens' StdEnv Bool
envSampler :: Lens' StdEnv Sampler

-- | A standard implementation of <a>tracerStart</a>.
stdTracer :: MonadIO m => StdEnv -> SpanOpts -> m Span

-- | A implementation of <a>tracerReport</a> that logs spans to stdout.
stdReporter :: MonadIO m => FinishedSpan -> m ()


-- | Types and functions for serializing and deserializing
--   <a>SpanContext</a>s across process boundaries.
--   
--   One of the big motiviating use cases for propagation is for tracing
--   distributed executions through RPC calls.
module OpenTracing.Propagation
type TextMap = HashMap Text Text
type Headers = [Header]

-- | A <a>Propagation</a> contains the different ways that a
--   <a>SpanContext</a> can be serialized and deserialized. For example
--   <tt>Propagation '[TextMap, Headers]</tt> indicates support for
--   serializing to <a>Header</a> or to <a>TextMap</a>.
type Propagation carriers = Rec Carrier carriers

-- | A typeclass for application environments that contain a
--   <a>Propagation</a>.
class HasPropagation a p | a -> p
propagation :: HasPropagation a p => Getting r a (Propagation p)

-- | `Carrier a` is a way to convert a <a>SpanContext</a> into or from an
--   <tt>a</tt>.
newtype Carrier a
Carrier :: Prism' a SpanContext -> Carrier a
[fromCarrier] :: Carrier a -> Prism' a SpanContext
type HasCarrier c cs = c ∈ cs
type HasCarriers cs ds = cs ⊆ ds

-- | Retrieve a (de)serialization lens from the application context for
--   format <tt>c</tt>.
carrier :: (HasCarrier c cs, HasPropagation r cs) => proxy c -> r -> Prism' c SpanContext

-- | Serialize a <a>SpanContext</a> into the format <tt>c</tt> using a
--   serializer from the application context.
inject :: forall c r p. (HasCarrier c p, HasPropagation r p) => r -> SpanContext -> c

-- | Attempt to deserialize a <a>SpanContext</a> from the format <tt>c</tt>
--   using a deserializer from the application context
extract :: forall c r p. (HasCarrier c p, HasPropagation r p) => r -> c -> Maybe SpanContext

-- | A propagation using an "ot" prefix. No parent span id is propagated in
--   OT.
otPropagation :: Propagation '[TextMap, Headers]

-- | A propagation using an "x-b3" prefix for use with Zipkin.
b3Propagation :: Propagation '[TextMap, Headers]
_OTTextMap :: Prism' TextMap SpanContext
_OTHeaders :: Prism' Headers SpanContext
_B3TextMap :: Prism' TextMap SpanContext
_B3Headers :: Prism' Headers SpanContext

-- | Convert between a <a>TextMap</a> and <a>Headers</a>
--   
--   Header field values are URL-encoded when converting from
--   <a>TextMap</a> to <a>Headers</a>, and URL-decoded when converting the
--   other way.
--   
--   Note: validity of header fields is not checked (RFC 7230, 3.2.4)
_HeadersTextMap :: Iso' Headers TextMap

-- | A record is parameterized by a universe <tt>u</tt>, an interpretation
--   <tt>f</tt> and a list of rows <tt>rs</tt>. The labels or indices of
--   the record are given by inhabitants of the kind <tt>u</tt>; the type
--   of values at any label <tt>r :: u</tt> is given by its interpretation
--   <tt>f r :: *</tt>.
data Rec (a :: u -> Type) (b :: [u]) :: forall u. () => u -> Type -> [u] -> Type
[RNil] :: forall u (a :: u -> Type) (b :: [u]). () => Rec a ([] :: [u])
[:&] :: forall u (a :: u -> Type) (b :: [u]) (r :: u) (rs :: [u]). () => !a r -> !Rec a rs -> Rec a (r : rs)
infixr 7 :&

-- | Two records may be pasted together.
rappend :: () => Rec f as -> Rec f bs -> Rec f (as ++ bs)

-- | A shorthand for <a>rappend</a>.
(<+>) :: () => Rec f as -> Rec f bs -> Rec f (as ++ bs)
infixr 5 <+>

-- | Takes a larger record to a smaller one by forgetting fields. This is
--   <a>rcastC</a> with the type arguments reordered for more convenient
--   usage with <tt>TypeApplications</tt>.
rcast :: (RecSubset record rs ss is, RecSubsetFCtx record f) => record f ss -> record f rs
instance OpenTracing.Propagation.HasPropagation (OpenTracing.Propagation.Propagation p) p


-- | The <a>OpenTracing spec</a> defines a platform agnostic approach for
--   distributed tracing. Distributed tracing gives us insights into how
--   complex programs spread across multiple processes are performing
--   together.
--   
--   This package provides a core implementation of the OpenTracing spec.
--   It includes functionality to
--   
--   <ul>
--   <li>Create <a>Span</a>s describing application code executions,
--   including <a>Tag</a>s and <a>LogRecord</a>s</li>
--   <li>Serialize and deserialize <a>SpanContext</a>s across process
--   boundaries</li>
--   <li>Batch and log <a>FinishedSpan</a>s</li>
--   </ul>
--   
--   It does not provide any functionality for consuming <a>Span</a>s.
--   There are platform specific backends (CloudTrace, Zipkin, Jaeger, etc)
--   that are provided in other packages.
module OpenTracing
type HasOpenTracing r p = (HasTracer r, HasPropagation r p)
type MonadOpenTracing r p m = (HasOpenTracing r p, MonadReader r m)
runOpenTracing :: HasOpenTracing r p => r -> ReaderT r m a -> m a
type MonadTracer r m = (HasTracer r, MonadReader r m)

-- | A <a>Tracer</a> is a set of effectful actions that define the
--   mid-level interface to an <a>OpenTracing tracer</a>
--   
--   Appliction code should generally construct a <a>Tracer</a> once and
--   then use other higher-level functions such as <a>traced</a>,
--   <a>startSpan</a>, <tt>finishedSpan</tt>.
data Tracer
Tracer :: (forall m. MonadIO m => SpanOpts -> m Span) -> (forall m. MonadIO m => FinishedSpan -> m ()) -> Tracer

-- | Start recording a new span with the given options. This is a mid-level
--   operation that will handle start timing and random span ID generation.
--   
--   Application code should supply this field with <tt>stdTracer</tt>.
[tracerStart] :: Tracer -> forall m. MonadIO m => SpanOpts -> m Span

-- | Report a finished span. What reporting means for each application will
--   depend on where this data is going. There are multiple backends that
--   define reporters for Google Cloudtrace, Zipkin, and Jaeger, for
--   example.
[tracerReport] :: Tracer -> forall m. MonadIO m => FinishedSpan -> m ()

-- | Typeclass for application environments that contain a <a>Tracer</a>.
class HasTracer a
tracer :: HasTracer a => Getting r a Tracer
runTracer :: HasTracer r => r -> ReaderT r m a -> m a

-- | Trace a computation as a span. This is a high-level operation that
--   will handle all aspects of the trace, including timing and reporting.
--   If the traced computation throws an excpetion, <a>traced</a> will
--   clean up and add logs before rethrowing the exception
--   
--   <pre>
--   traced (spanOpts "hello" mempty          ) $ parent -&gt;
--   traced (spanOpts "world" (childOf parent)) $ child -&gt;
--      liftIO $ do
--          putStrLn "doing some work..."
--          addLogRecord child (Message "doing some work")
--          threadDelay 500000
--   </pre>
traced :: (MonadTracer r m, MonadMask m, MonadIO m) => SpanOpts -> (ActiveSpan -> m a) -> m (Traced a)

-- | Variant of <a>traced</a> that doesn't return the wrapped value.
traced_ :: (MonadTracer r m, MonadMask m, MonadIO m) => SpanOpts -> (ActiveSpan -> m a) -> m a
startSpan :: (MonadTracer r m, MonadIO m) => SpanOpts -> m ActiveSpan
finishSpan :: (MonadTracer r m, MonadIO m) => ActiveSpan -> m FinishedSpan

-- | Attempt to deserialize a <a>SpanContext</a> from the format <tt>c</tt>
--   using a deserializer from the application context. See
--   <a>Propagation</a> for more info.
extract :: forall c r p m. (MonadPropagation r p m, HasCarrier c p) => c -> m (Maybe SpanContext)

-- | Serialize a <a>SpanContext</a> into the format <tt>c</tt> using a
--   serializer from the application context. See <a>Propagation</a> for
--   more info.
inject :: forall c r p m. (MonadPropagation r p m, HasCarrier c p) => SpanContext -> m c

-- | Takes a larger record to a smaller one by forgetting fields. This is
--   <a>rcastC</a> with the type arguments reordered for more convenient
--   usage with <tt>TypeApplications</tt>.
rcast :: (RecSubset record rs ss is, RecSubsetFCtx record f) => record f ss -> record f rs

-- | A shorthand for <a>rappend</a>.
(<+>) :: () => Rec f as -> Rec f bs -> Rec f (as ++ bs)
infixr 5 <+>

-- | Two records may be pasted together.
rappend :: () => Rec f as -> Rec f bs -> Rec f (as ++ bs)

-- | A record is parameterized by a universe <tt>u</tt>, an interpretation
--   <tt>f</tt> and a list of rows <tt>rs</tt>. The labels or indices of
--   the record are given by inhabitants of the kind <tt>u</tt>; the type
--   of values at any label <tt>r :: u</tt> is given by its interpretation
--   <tt>f r :: *</tt>.
data Rec (a :: u -> Type) (b :: [u]) :: forall u. () => u -> Type -> [u] -> Type
[RNil] :: forall u (a :: u -> Type) (b :: [u]). () => Rec a ([] :: [u])
[:&] :: forall u (a :: u -> Type) (b :: [u]) (r :: u) (rs :: [u]). () => !a r -> !Rec a rs -> Rec a (r : rs)
infixr 7 :&
type HasCarriers cs ds = cs ⊆ ds
type HasCarrier c cs = c ∈ cs

-- | `Carrier a` is a way to convert a <a>SpanContext</a> into or from an
--   <tt>a</tt>.
newtype Carrier a
Carrier :: Prism' a SpanContext -> Carrier a
[fromCarrier] :: Carrier a -> Prism' a SpanContext

-- | A typeclass for application environments that contain a
--   <a>Propagation</a>.
class HasPropagation a p | a -> p
propagation :: HasPropagation a p => Getting r a (Propagation p)

-- | A <a>Propagation</a> contains the different ways that a
--   <a>SpanContext</a> can be serialized and deserialized. For example
--   <tt>Propagation '[TextMap, Headers]</tt> indicates support for
--   serializing to <a>Header</a> or to <a>TextMap</a>.
type Propagation carriers = Rec Carrier carriers
type Headers = [Header]
type TextMap = HashMap Text Text

-- | Retrieve a (de)serialization lens from the application context for
--   format <tt>c</tt>.
carrier :: (HasCarrier c cs, HasPropagation r cs) => proxy c -> r -> Prism' c SpanContext

-- | A propagation using an "ot" prefix. No parent span id is propagated in
--   OT.
otPropagation :: Propagation '[TextMap, Headers]

-- | A propagation using an "x-b3" prefix for use with Zipkin.
b3Propagation :: Propagation '[TextMap, Headers]
_OTTextMap :: Prism' TextMap SpanContext
_OTHeaders :: Prism' Headers SpanContext
_B3TextMap :: Prism' TextMap SpanContext
_B3Headers :: Prism' Headers SpanContext

-- | Convert between a <a>TextMap</a> and <a>Headers</a>
--   
--   Header field values are URL-encoded when converting from
--   <a>TextMap</a> to <a>Headers</a>, and URL-decoded when converting the
--   other way.
--   
--   Note: validity of header fields is not checked (RFC 7230, 3.2.4)
_HeadersTextMap :: Iso' Headers TextMap
